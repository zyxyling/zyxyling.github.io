<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/30/hello-world/"/>
    <url>/2020/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Feel &amp; Wait</title>
    <link href="/2020/12/20/62300-Feel%20&amp;%20Wait/"/>
    <url>/2020/12/20/62300-Feel%20&amp;%20Wait/</url>
    
    <content type="html"><![CDATA[<h2 id="Feel-amp-Wait"><a href="#Feel-amp-Wait" class="headerlink" title="Feel &amp; Wait"></a>Feel &amp; Wait</h2><p>![15](F:\BLOG\bolg\hexoblog\source_posts\62300-Feel &amp; Wait\15.png)</p><blockquote><p>适我愿兮，不期而遇……</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读-Relation-Aware Graph Attention Network for Visual Question Answering</title>
    <link href="/2020/12/20/20001-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Relation-Aware%20Graph%20Attention%20Network%20for%20Visual%20Question%20Answering/"/>
    <url>/2020/12/20/20001-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Relation-Aware%20Graph%20Attention%20Network%20for%20Visual%20Question%20Answering/</url>
    
    <content type="html"><![CDATA[<blockquote><p>论文阅读</p><p>GAT-VQA</p><p>ICCV.2019</p><p>Relation-Aware Graph Attention Network for Visual Question Answering 用于视觉问答的关系感知图注意力网络</p><p>原文：<a href="https://arxiv.org/pdf/1903.12314.pdf">https://arxiv.org/pdf/1903.12314.pdf</a></p></blockquote><h1 id="论文阅读-Relation-Aware-Graph-Attention-Network-for-Visual-Question-Answering"><a href="#论文阅读-Relation-Aware-Graph-Attention-Network-for-Visual-Question-Answering" class="headerlink" title="论文阅读-Relation-Aware Graph Attention Network for Visual Question Answering"></a>论文阅读-Relation-Aware Graph Attention Network for Visual Question Answering</h1><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a><strong>一、标题</strong></h2><p>Relation-Aware Graph Attention Network for Visual Question Answering</p><p>用于视觉问答的关系感知图注意力网络</p><h2 id="二、引用"><a href="#二、引用" class="headerlink" title="二、引用"></a><strong>二、引用</strong></h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[<span class="hljs-number">1</span>] Linjie Li, Zhe Gan, Yu Cheng, Jingjing Liu. <span class="hljs-string">&quot;Relation-Aware Graph Attention Network for Visual Question Answering.&quot;</span> In The International Conference <span class="hljs-keyword">on</span> Computer Vision (ICCV), <span class="hljs-number">2019</span><br></code></pre></td></tr></table></figure><h2 id="三、出处"><a href="#三、出处" class="headerlink" title="三、出处"></a><strong>三、出处</strong></h2><p>ICCV 2019</p><h2 id="四、原文链接"><a href="#四、原文链接" class="headerlink" title="四、原文链接"></a><strong>四、</strong>原文链接</h2><p><a href="https://arxiv.org/pdf/1903.12314.pdf">https://arxiv.org/pdf/1903.12314.pdf</a></p><h2 id="五、论文主要内容"><a href="#五、论文主要内容" class="headerlink" title="五、论文主要内容"></a>五、论文主要内容</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><p>​        为了回答关于图像的复杂语义问题，视觉问答$（VQA）$模型需要更好地理解图像中的视觉场景，尤其是不同对象之间的动态交互。作者提出了一种关系感知图注意力网络$（ReGAT）$，该网络将每个图像编码成一个图，并通过图注意力机制对多种类型的内在关系对象间进行建模，以学习自适应问题的关系表示。 探讨了两种类型的视觉对象关系：（i）显示关系，即表示对象之间的几何位置和语义交互； （ii）隐式关系，用于捕获图像区域之间的隐含活动。 实验表明，$ReGAT$在$VQA 2.0$和$VQA-CP v2$数据集上均优于现有技术。 我们进一步证明$ReGAT$与现有的$VQA$体系结构兼容，并且可以用作通用关系编码器以提高$VQA$的模型性能。</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a><strong>1.</strong>  <strong>介绍</strong></h3><p>​        深度学习的最新进展推动了计算机视觉和自然语言处理（NLP）方面的巨大进步。 语言和视觉之间的跨学科领域，例如图像标题，文本生成图像和视觉问答（VQA），已引起视觉和NLP社区的迅速关注。 以VQA为例-目标（也是主要挑战）是训练一个模型，该模型可以实现对多模态输入的全面且语义一致的理解。 具体地，给定图像和基于图像的自然语言问题，任务是将图像中的视觉特征与问题中的语义相关联，以便正确回答问题。</p><p>​        VQA的大多数最新方法[56、11、38、33、49]都集中于学习图像和问题的多模态联合表示。 具体而言，卷积神经网络（CNN）或基于区域的CNN（R-CNN）通常用作图像编码的视觉特征提取器，而递归神经网络（RNN）用于问题编码。 从视觉特征提取器获得一组稀疏的图像区域后，应用多模态融合来学习一个联合表示，该联合表示表示每个单独区域与问题之间的对齐方式。然后将此联合表示形式输入到答案预测器中以产生答案。</p><p>​        事实证明，该框架对于VQA任务很有用，但是图像和自然语言之间仍然存在巨大的语义鸿沟。 例如，给定一组斑马的图像（参见图1），模型可以识别黑色和白色像素，但不能识别来自哪个斑马的白色和黑色像素。 因此，很难回答诸如“<em>最右边的斑马是小斑马吗？</em>”或“<em>所有斑马都在吃草吗？</em>” 之类的问题。 VQA系统不仅需要识别对象（“斑马”）和周围环境（“草”），还需要识别图像和图像中有关动作（“饮食”）和位置（“最右边”）信息。</p><p>​        为了捕获这种类型的动作和位置信息，我们不仅需要在图像理解中进行对象检测，还需要通过解释图像中<font color=Blue>不同对象之间的动态和相互作用</font>来了解图像中视觉场景的更全面视图 。 一种可能的解决方案是检测相邻物体的相对几何位置（例如<motorcycle-next to-car>），以与问题中的空间描述保持一致。 另一个方向是学习对象之间的语义依赖性（例如<girl-eating-cake>），以捕获视觉场景中的交互式动态。</p><p>​        为此，我们提出了一种用于VQA的关系感知图注意力网络（ReGAT），引入了一种新颖的关系编码器，<font color=Blue>该编码器可捕获静态对象/区域检测之外的这些对象间关系。 这些视觉关系特征可以揭示图像中更细粒度的视觉概念，从而提供整体的场景解释，可用于回答语义复杂的问题。</font> 为了覆盖图像场景和问题类型中的高方差<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="较大的差异度，描述与场景">[1]</span></a></sup>，关系编码器学习了显式（例如，空间/位置，语义/可操作）关系和隐式关系，其中图像表示为图，并且通过图注意力机制捕获了对象之间的交互。</p><p>进一步，基于问题的上下文来学习图注意力，从而允许将语义信息从问题注入到关系编码阶段。 这样，关系编码器学习到的特征不仅捕获图像中与对象互动的视觉内容，而且吸收问题中的语义线索，从而动态地关注每个问题的特定关系类型和实例。</p><p><img src="F:\BLOG\blog\hexoblog\themes\fluid\source\img\ReGAT.png" alt="img"></p><p>​    图1. ReGAT模型的概述。 同时考虑了显式关系（语义和空间关系）和隐式关系。</p><p>​    所提出的关系编码器通过“图注意力”捕获自适应问题的对象交互。</p><p>​        图1显示了所提出模型的概述。首先，使用Faster R-CNN生成一组候选区域，并使用问题编码器进行问题嵌入。 然后将每个区域的卷积和边界框特征注入到关系编码器中，以从图像中学习关系感知、问题自适应、区域级表示。 然后将这些具有关系感知的视觉特征和问题嵌入馈送到多模态融合模块中以生成联合表示，该联合表示在答案预测模块中用于生成答案。</p><p>​        原则上，我们的工作不同于（并兼容）现有的VQA系统。 它着眼于一个新的维度：使用问题自适应对象间关系来丰富图像表示，以增强VQA性能。我们的工作有以下三方面的贡献：</p><p>​        •我们提出了一种新颖的基于图的关系编码器，以通过图注意力网络学习视觉对象之间的显式和隐式关系。</p><p>​         •学习的关系是问题自适应的 ，这意味着它们可以动态捕获与每个问题最相关的视觉对象关系。</p><p>​        •我们表明，我们的ReGAT模型是一种通用方法，可用于改进VQA 2.0数据集上的最新VQA模型。 我们的模型还在更具挑战性的VQA-CP v2数据集上实现了最先进的性能。</p><h3 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2.  相关工作"></a><strong>2.</strong>  <strong>相关工作</strong></h3><h4 id="2-1-VQA"><a href="#2-1-VQA" class="headerlink" title="2.1  VQA"></a>2.1  VQA</h4><p>​        VQA 系统当前的主流框架包括图像编码器、问题编码器、多模态融合和答案预测器。代替直接使用基于CNN的特征提取器的视觉特征，[56、11、41、33、49、38、63、36]探索了各种图像注意力机制来定位与问题相关的区域。 为了更好地表达问题，[33，38，11]提出了协作进行问题导向的图像注意力和图像导向的问题注意力，以在编码阶段将视觉和文本模态中的知识进行合并。 [15，25，60，4，24]探索了更高阶的融合方法，以更好地将文本信息与视觉信息相结合（例如，使用双线性池代替诸如求和，串联和乘法之类的更简单的一阶方法）。</p><p>​        为了使模型更易于解释，一些文献[30、59、29、54、55、53]还利用了图像中的高级语义信息，例如属性，标题和视觉关系事实。 这些方法大多数都使用独立于VQA的模型从图像中提取语义知识，而[34]建立了Relation-VQA数据集并直接挖掘特定于VQA的关系事实，以将额外的语义信息提供给模型。 最近的一些研究[48，35，29]研究了如何结合记忆来辅助推理步骤，特别是对于有难度的问题。</p><p>​        但是，由记忆或高级语义信息带来的语义知识通常会转换为文本表示形式，而不是直接用作包含大量有关图像的指示性信息的视觉表示形式。 我们的工作是对这些先前研究的补充，因为我们将对象关系直接编码为图像表示形式，并且关系编码步骤是通用的，自然可以适合任何最新的VQA模型。</p><h4 id="2-2-视觉关系"><a href="#2-2-视觉关系" class="headerlink" title="2.2 视觉关系"></a>2.2 视觉关系</h4><p>​        在深度学习流行之前，已经探索了视觉关系。 早期工作[10、14、7、37]提出了通过将对象关系（例如，共现[10]，位置和大小[5]）视为对象检测的后处理步骤来对得分进行重新评分的方法。 先前的一些工作[16，17]还探讨了对象之间的空间关系（例如，“上方”，“周围”，“下方”和“内部”）可以帮助改善图像分割的想法。</p><p>​        事实证明，视觉关系对于许多计算机视觉任务至关重要。 例如，它有助于将图像映射到标题[13，12，58]的认知任务，并改善了图像搜索[47，23]和对象定位[45，21]。 视觉关系的最新研究[45、43、9]更加关注非空间关系，或称为“语义关系”（即对象的动作或对象之间的相互作用）。为视觉关系预测任务[32，8，61]设计了一些神经网络架构。</p><p><img src="F:\BLOG\blog\hexoblog\themes\fluid\source\img\ReGAT1.png" alt="img"></p><p>​        图2.提出的用于视觉问题回答的ReGAT的模型架构。更快的R-CNN用于检测一组对象区域。 然后将这些区域级特征馈入不同的关系编码器中，以学习可识别关系的问题的视觉特征，并将其与问题表示法融合以预测答案。为了简单起见，省略了多模态融合和答案预测变量。</p><h4 id="2-3-关系推理"><a href="#2-3-关系推理" class="headerlink" title="2.3 关系推理"></a>2.3 关系推理</h4><p>​        我们将上述视觉关系命名为显式关系，这已被证明对图像字幕有效[58]。 具体来说，[58]利用了从视觉基因组数据集[28]和对象之间的空间关系中学到的预定义语义关系。 基于这些关系构造图，并进行图卷积网络（GCN）[26]用于学习每个对象的表示。</p><p>​         另一研究重点是隐式关系，其中不使用显式语义或空间关系来构造图形。 取而代之的是，所有关系都由注意力模块或通过高阶方法隐式捕获到输入图像的完全连接图上[46、21、6、57]，以对检测到的对象之间的交互进行建模。 例如，[46]通过使用简单的MLP<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="多层感知器(Multi-Layer Perceptron，MLP)">[2]</span></a></sup>     对图像中所有可能的对象对进行推理。在[6]中，引入了一种双线性融合方法，称为MuRel单元，以进行成对关系建模。</p><p>​        已经提出了一些其他工作[50、39、52]，用于学习图像的问题条件图表示。 具体来说，[39]介绍了一种图学习器模块，该模块以问题表示为条件，以使用成对注意和空间图卷积来计算图像表示。 [50]利用结构化的问题表示形式，例如解析树，并使用GRU对对象和单词之间的上下文交互进行建模。较新的工作[52]引入了由类间/类间边缘定义的稀疏图，其中关系是通过语言指导的图注意机制隐式学习的。 但是，所有这些工作仍集中在隐式关系上，隐式关系比显式关系难解释。</p><p><strong>我们的贡献</strong></p><p>​        我们的工作受到[21，58]的启发。但是，与它们不同，ReGAT同时考虑了显式和隐式关系来丰富图像表示。对于显式关系，我们的模型使用图注意力网络（GAT）而非[58]中使用的简单GCN。 与GCN相对，GAT的使用允许为同一邻域的节点分配不同的重要性。 对于隐式关系，我们的模型通过过滤掉与问题无关的关系，而不是像在[21]中一样地处理所有其他关系，来学习一个适用于每个问题的图。在实验中，我们进行了详细的消融研究 ，以证明每个单独设计的有效性。</p><h3 id="3-关系感知图注意力网络"><a href="#3-关系感知图注意力网络" class="headerlink" title="3.  关系感知图注意力网络"></a><strong>3.</strong>  <strong>关系感知图注意力网络</strong></h3><p>下面是VQA任务的问题定义:给定一个基于图像I的问题q，目标是预测一个答案a，这个答案a^ ∈A与基本事实答案a* 最匹配。作为VQA文献中的常见实践，这可以定义为一个分类问题：</p><p><img src="F:\BLOG\blog\hexoblog\themes\fluid\source\img\ReGAT2.png" alt="img"></p><p>其中pθ是训练后的模型。</p><pre><code>      图2给出了我们提出的模型的详细说明，该模型由图像编码器，问题编码器和关系编码器组成。 对于图像编码器，Faster R-CNN [2]用于标识一组对象V = &#123;vi&#125; K i = 1，其中每个对象vi都与视觉特征向量vi∈R dv和边界框相关联 特征向量bi∈R db（在我们的实验中，K = 36，dv = 2048，并且db = 4）。 每个bi = [x，y，w，h]对应于4维空间坐标，其中（x，y）表示边界框左上点的坐标，而h / w对应于边框的高度/宽度 盒子。 对于问题编码器，我们使用带有门控循环单元（GRU）的双向RNN，并对RNN隐藏状态的序列进行自我关注，以生成问题嵌入![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image008.gif)（在我们的实验中，d q = 1024）。 以下小节将说明关系编码器的详细信息。</code></pre><h4 id="3-1-图结构"><a href="#3-1-图结构" class="headerlink" title="3.1 图结构"></a>3.1 图结构</h4><p><strong>全连接关系图</strong></p><p>​        通过将图像中的每个对象vi视为一个顶点，我们可以构建完全连接的无向图G imp =（V，E），其中E是K×（K − 1）个边的集合。 每个边缘代表两个对象之间的隐式关系，这可以通过学习图的注意力分配给每个边缘分配的权重来反映。 无需任何先验知识即可隐式学习所有权重。 我们将基于该图Gimp的关系编码器命名为隐式关系编码器。</p><p><strong>先验知识剪枝图</strong></p><p>​        另一方面，如果可以使用顶点之间的解释，则可以通过修剪不存在相应显式关系的边来将完全连接的图G imp轻松转换为显式关系图。 对于每对对象i，j，如果<i-p-j>是有效关系，则从i到j创建一条边缘，并带有边缘标签p。 此外，我们为每个对象节点i分配一个自环边，并将该边标记为相同。 以这种方式，图变得稀疏，并且每个边缘都编码有关图像中一个对象间关系的先验知识。 我们将基于此图的关系编码器命名为显式关系编码器。</p><pre><code>  这些功能的显式本质要求经过预训练的分类器以离散类标签的形式提取关系 ，这些类标签表示对人眼显性的对象之间的动态关系和交互作用。 基于此修剪图，可以学习不同类型的显式关系。 在本文中，我们探索了两个实例：空间图和语义图，以捕获对象之间的位置关系和可操作关系，这对于视觉问题的回答是必不可少的。</code></pre><p><strong>空间图</strong></p><p>​        令spa i，j = &lt;对象i-谓词-对象j&gt;表示表示对象i与对象i的相对几何位置的空间关系。</p><pre><code>   为了构造空间图G spa，给定两个对象区域提议对象i和对象j，我们将spa i，j分为11个不同类别[58]（例如，对象i在对象j（类1）内，对象j 在对象i（类2）内部，如图3（a）所示，其中包括为彼此距离太远的对象保留的无关系类。 请注意，由空间关系形成的边是对称的：如果&lt;object i -pi，j -object j&gt;是有效的空间关系，则必须存在有效的空间关系spa j，i = &lt;object j -pj，i -object i &gt;。 但是，两个谓词p i，j和p j，i是不同的。</code></pre><p><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT3.png" alt="img"><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT4.png" alt="img"></p><p> (a) Spatial Relation                    (b) Semantic Relation</p><p>图3.空间和语义关系的图示。 绿色箭头表示关系的方向（主题→对象）。 绿色框中的标签是关系的类标签。 红色和蓝色框包含对象的类标签。</p><p><strong>语义图</strong></p><p>​        为了构造语义图G sem，需要提取对象之间的语义关系（例如，<subject-predicate-object>）。通过在视觉关系数据集（例如，视觉基因组[27]）上训练语义关系分类器，可以将其表达为分类任务[58]。 给定两个对象区域i和j，目标是确定哪个谓词p表示这两个区域之间的语义关系<i-p-j>。 在此，主题j和对象i之间的关系是不可互换的，这意味着由语义关系形成的边缘不是对称的。 对于有效的&lt;i-p i，j -j&gt;，在我们的定义中可能不存在关系&lt;j-p j.i -i&gt;。 例如，<man-holding-bat>是有效关系，而从bat到man没有语义关系。</p><p>分类模型接受三个输入：主题区域vi的特征向量，对象区域vj的特征向量， 包含i和j的联合边界框的区域级特征向量vi，j。 这三种类型的特征是从预训练的目标检测模型中获得的，然后通过嵌入层进行转换。然后将嵌入的特征进行连接并馈入分类层，以在14个语义关系上产生softmax概率，并附加一个无关系 类。 然后将训练后的分类器用于预测给定图像中任何一对对象区域之间的关系。 语义关系的示例在图3（b）中显示。</p><h4 id="3-2-关系编码器"><a href="#3-2-关系编码器" class="headerlink" title="3.2 关系编码器"></a>3.2 关系编码器</h4><p><strong>问题自适应图注意力</strong></p><p>​        提出的关系编码器旨在对图像中的对象之间的动态关系进行编码。 对于VQA任务，可能存在对不同问题类型有用的不同类型的关系。 因此，在设计关系编码器时，我们使用问题自适应注意机制将问题的语义信息注入到关系图中，以便为与每个问题最相关的那些关系动态分配更高的权重。这是通过首先将嵌入q的问题与K个视觉特征v i的每一个串联来实现的，表示为</p><p> <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image014.gif" alt="img"></p><p>​        然后在顶点上执行自注意力，这会生成隐藏的关系特征<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image016.gif" alt="img">，这些特征表征目标对象及其邻近对象之间的关系。</p><p>​        基于此，每个关系图都要经过以下注意机制：</p><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image018.gif" alt="img"></p><p>​        对于不同类型的关系图，关注系数αij的定义会发生变化，投影矩阵<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image020.jpg" alt="img">和对象i的邻域<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image022.jpg" alt="img">也会发生变化。</p><p>​         σ（·）是一个非线性函数，例如ReLU。 为了稳定自我注意力的学习过程，我们还通过采用多头注意力扩展了上述图注意力机制，其中执行了M个独立的注意力机制，并连接了它们的输出特征，从而得到以下输出特征表示</p><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image024.gif" alt="img"></p><p>​        最后，将<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image026.jpg" alt="img">添加到原始视觉特征vi中，以充当最终的关系感知特征。</p><p><strong>隐含关系</strong></p><p>​        由于用于学习隐式关系的图是全连接的，因此<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image027.jpg" alt="img">包含图像中的所有对象，包括对象i本身。 受[21]启发，我们将注意力权重<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image029.jpg" alt="img"> 设计为不仅取决于视觉特征权重<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image031.jpg" alt="img">，而且还取决于边界框权重<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image033.jpg" alt="img">。 特别，</p><p><strong><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image035.gif" alt="img"></strong></p><p>其中，<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image036.jpg" alt="img">表示视觉特征之间的相似度，通过缩放的点积[51]计算得出：</p><p><strong><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image038.gif" alt="img"></strong></p><p>其中<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image040.jpg" alt="img">是投影矩阵。<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image033.jpg" alt="img">测量任何一对区域之间的相对几何位置：</p><p><strong><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image042.gif" alt="img"></strong></p><p>其中fb（·，·）首先计算4维相对几何特征<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image044.jpg" alt="img"> ，然后通过计算不同波长的余弦和正弦函数，将其转换为一个dh维的特征。 <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image046.gif" alt="img"> <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image048.gif" alt="img">将dh维的特征转换为标量权重，将其进一步修剪为0。与我们在显式关系设置中假设彼此之间距离太远的对象无关系不同，隐式关系的限制 通过w和零调整操作获知。</p><p><strong>显式关系</strong></p><p>​        我们首先考虑语义关系编码器。 由于语义图 <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image050.jpg" alt="img"> 中的边现在包含标签信息并且是有方向的，因此我们将（3）中的注意力机制设计为对方向性<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image052.jpg" alt="img">和标签都敏感。 特别，</p><p><strong><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image054.gif" alt="img"></strong></p><p>​        其中W {·}，V {·}是矩阵，b {·}，c {·}是偏置项。 dir（i，j）选择每个边的方向性的变换矩阵，而lab（i，j）代表每个边的标签。 因此，在通过上述图注意力机制对所有区域<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image056.jpg" alt="img">进行编码之后，精细化的区域级特征<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image058.jpg" alt="img">被赋予对象之间的先验语义关系。</p><pre><code>  与图卷积网络相反，该图注意力机制有效地将不同的重要性分配给相同邻域的节点。 结合问题自适应机制，学习注意权重可以反映出哪些关系与特定问题相关。 相关编码器可以在空间图![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image060.jpg)上以相同的方式工作，具有要学习的不同参数集，因此为简单起见，省略了详细信息。</code></pre><h4 id="3-3-多模态融合与答案预测"><a href="#3-3-多模态融合与答案预测" class="headerlink" title="3.3 多模态融合与答案预测"></a>3.3 多模态融合与答案预测</h4><p>​        在获得关系感知的视觉特征之后，我们希望通过多模型融合策略将问题信息q与每个视觉表示 <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image062.jpg" alt="img"> 融合。 由于我们的关系编码器保留了视觉特征的维数，因此可以将其与任何现有的多模式融合方法结合使用，以学习联合表示J：</p><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image064.gif" alt="img"></p><p>其中f是多模式融合方法，而Θ是融合模块的可训练参数。</p><p>​        对于答案预测器，我们采用两层多层感知器（MLP）作为分类器，联合表示形式J为输入 。 类似于[2]，二进制交叉熵被用作损失函数。</p><pre><code>    在训练阶段，对不同的关系编码器进行独立训练。 在推论阶段，我们将三个图注意力网络与预测答案分布的加权和相结合。 具体而言，最终答案分布由以下公式计算：</code></pre><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image066.gif" alt="img"></p><p>其中α和β是权衡的超参数（0≤α+β≤1,0≤α，β≤1）。  <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image068.jpg" alt="img">和<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image070.jpg" alt="img">分别表示根据语义，空间和隐式关系训练的模型的预测答案<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image072.jpg" alt="img"> 的概率。</p><h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4.  实验"></a><strong>4.</strong>  <strong>实验</strong></h3><p>我们在VQA 2.0和VQA-CP v2数据集[3，19，1]上评估了我们提出的模型。 此外，Visual Genome [27]用于预训练语义关系分类器。 在testdev和test-std拆分上进行测试时，它还用于扩充VQA数据集。 我们使用准确性作为评估指标：</p><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image074.gif" alt="img"></p><h4 id="4-1-数据集"><a href="#4-1-数据集" class="headerlink" title="4.1 数据集"></a>4.1 数据集</h4><p>​        VQA 2.0数据集由MSCOCO [31]的真实图像组成，具有相同的训练/验证/测试分割。对于每个图像，平均会生成3个问题。 这些问题分为3类：是/否，数字和其他。 从人类注释者那里为每个图像问题对收集了10个答案，最频繁的答案被选为正确答案。 此数据集中包括开放式和多项选择题类型。 在这项工作中，我们将重点放在开放性任务上，并将在训练集中出现超过9次的答案作为候选答案，从而产生3,129个候选答案。 该模型是在训练集上训练的，但是在测试集上进行测试时，训练集和验证集都用于训练，并且将最大概率答案选择为预测答案。</p><p>​      VQA-CP v2数据集是VQA 2.0数据集的派生，它被引入以评估和减少VQA模型中面向问题的偏见。 特别是，关于问题类型的答案分布在训练和测验拆分之间是不同的。</p><pre><code>    Visual Genome包含108K图像，这些图像带有密集注释的对象，属性和关系，我们使用它们来预先训练模型中的语义关系分类器。 我们过滤掉了那些也出现在VQA验证集中的图像，并将关系数据分为88K进行训练，8K进行验证和8K进行测试。 此外，在使用Visual Genome中提供的关系别名对谓词进行归一化后，我们在训练数据中选择了前14个最频繁的谓词。 最终的语义关系分类器经过14个关系类以及一个无关系类的训练。</code></pre><h4 id="4-2-实施细节"><a href="#4-2-实施细节" class="headerlink" title="4.2 实施细节"></a>4.2 实施细节</h4><p>​        每个问题都被标记，每个单词都使用600维单词嵌入（包括300维GloVe单词嵌入[42]）。 然后将嵌入单词的序列在每个时间步长之前馈入GRU，直到第14个令牌为止（类似于[24]）。 少于14个单词的问题在结尾处填充零个向量。 GRU中隐藏层的维数设置为1024。我们对所有三个图形注意网络采用16头的多头注意。 关系特征的尺寸设置为1024。对于隐式关系，我们将嵌入的相对几何特征尺寸d h设置为64。</p><p>​          对于语义关系分类器，我们结合ResNet-101 [20]，从Faster R-CNN [44]模型中提取具有已知边界框的预训练对象检测特征。 更具体地说，特征是从Res4b22特征图[58]进行RoI合并后Pool5层的输出。 Faster R-CNN模型训练了1,600个选定的对象类别和400个属性类别，类似于自下而上的注意[2]。</p><p>​        我们的模型基于PyTorch [40]实现。 在实验中，我们使用Adamax优化器进行训练，最小批量大小为256。对于学习率的选择，我们采用热身策略[18]。 具体来说，我们以0.0005的学习率开始，在每个周期线性增加它，直到在第4个周期达到0.002。在15个周期之后，每2个周期直至20个周期，学习率降低1/2。 每个线性映射都通过权重和丢弃进行归一化（p = 0.2，但分类器为0.5）。</p><h4 id="4-3-实验结果"><a href="#4-3-实验结果" class="headerlink" title="4.3 实验结果"></a>4.3 实验结果</h4><p>​        本小节提供了有关VQA 2.0和VQA-CP v2数据集的实验结果。 通过设计，关系编码器可以作为即插即用组件组合到不同的VQA体系结构中。 在我们的实验中，我们考虑了三种具有不同多模态融合方法的流行VQA模型：自下而上，自上而下[2]（BUTD），多模态塔克融合[4]（MUTAN）和双线性注意力网络[24]（BAN）。 表1报告了以下设置中的VQA 2.0验证集的结果：</p><pre><code>  •Imp / Sem / Spa：仅一种类型的关系（隐式，语义或空间关系）用于合并自下而上的注意力特征。</code></pre><p>​      •Imp + Sem / Imp + Spa / Sem + Spa：通过加权和使用两种不同类型的关系。</p><p>​      •全部：通过加权和使用所有三种关系（例如：α= 0.4，β= 0.3）。 参见等式。 （10）有关详细信息。</p><p>​        与基线模型相比，在添加建议的关系编码器之后，我们可以观察到所有三种架构的性能均得到稳定的提高。 这些结果表明，我们的ReGAT模型是一种通用方法，可用于改进最新的VQA模型。 此外，结果表明，每个单个关系都有助于提高性能，并且关系的成对组合可以实现一致的性能增益。 当所有这三种类型组合在一起时，我们的模型可以达到最佳性能。 通过将最佳单关系模型与加权总和相结合，可以实现最佳结果。 为了验证性能提升是否显着，我们对BAN基准和我们建议的模型的每个关系进行了t-test检验。 我们在表1中报告了标准偏差，p值为0.001459。 我们方法的改进在p &lt;0.05时很明显。 我们还与使用BiLSTM作为上下文关系编码器的其他基线模型进行了比较，结果表明，使用BiLSTM会损害性能。</p><p><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT5.png" alt="img"></p><p>表1.使用不同融合方法的VQA 2.0验证集的性能。 在3种流行的融合方法中观察到了一致的改进，这表明我们的模型与通用VQA框架兼容。 （†）结果基于我们的重新实施。</p><p><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT6.png" alt="img"></p><p>表2. VQA-CP v2基准上的模型准确性（测试拆分上的开放式设置）。</p><p><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT7.png" alt="img"></p><p>表3. VQA 2.0基准上的模型准确性（test-dev和test-std拆分的开放式设置）。</p><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/06/clip_image082.gif" alt="img"></p><p>表4.用于消融研究的VQA 2.0验证集的性能（支持Q：支持问题；提示：Attention）。</p><p>​        为了证明ReGAT模型的通用性，我们还对VQA-CP v2数据集进行了实验，其中训练和测试拆分的分布彼此非常不同。 表2显示了VQA-CP v2测试拆分的结果。 在这里，我们使用具有四次瞥见的BAN作为基准模型。 与我们在VQA 2.0上观察到的一致，我们的ReGAT模型大大超过了基线。 仅凭单一关系，我们的模型就已经在VQACP v2上实现了最先进的性能（40.30与39.54）。 加上所有关系后，性能提升进一步提高到+0.88。</p><p>​      表3显示了VQA 2.0 test-dev和test-std拆分的单模型结果。 前五行显示的是没有关系推理的模型的结果，而后四行则是具有关系推理的模型的结果。 我们的模型可以胜任所有以前的工作，也可以不进行任何关系推理。 我们的最终模型将双线性注意和四次瞥视作为多峰融合方法。 与使用8个双线性注意图的BAN [24]相比，我们的模型在BAN方面的表现要好得多。 Pythia [22]通过添加其他网格级别的功能并针对所有图像在VQA数据集上使用经过微调的Faster R-CNN的100个对象建议来达到70.01。 我们的模型没有在工作中使用任何功能增强功能，其性能大大超过了Pythia。</p><h4 id="4-4-消融研究-lt-span-class-”hint–top-hint–rounded”-aria-label-”消融研究-通常是指删除模型或算法的一些”功能”，并查看这如何影响性能。实际上ablation-study就是为了研究模型中所提出的一些结构是否有效而设计的实验。比如你提出了某某结构，但是要想确定这个结构是否有利于最终的效果，那就要将去掉该结构的网络与加上该结构的网络所得到的结果进行对比，这就是ablation-study"><a href="#4-4-消融研究-lt-span-class-”hint–top-hint–rounded”-aria-label-”消融研究-通常是指删除模型或算法的一些”功能”，并查看这如何影响性能。实际上ablation-study就是为了研究模型中所提出的一些结构是否有效而设计的实验。比如你提出了某某结构，但是要想确定这个结构是否有利于最终的效果，那就要将去掉该结构的网络与加上该结构的网络所得到的结果进行对比，这就是ablation-study" class="headerlink" title="4.4 消融研究&lt;span class=”hint–top hint–rounded” aria-label=”消融研究: 通常是指删除模型或算法的一些”功能”，并查看这如何影响性能。实际上ablation study就是为了研究模型中所提出的一些结构是否有效而设计的实验。比如你提出了某某结构，但是要想确定这个结构是否有利于最终的效果，那就要将去掉该结构的网络与加上该结构的网络所得到的结果进行对比，这就是ablation study"></a>4.4 消融研究<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”消融研究: 通常是指删除模型或算法的一些”功能”，并查看这如何影响性能。实际上ablation study就是为了研究模型中所提出的一些结构是否有效而设计的实验。比如你提出了某某结构，但是要想确定这个结构是否有利于最终的效果，那就要将去掉该结构的网络与加上该结构的网络所得到的结果进行对比，这就是ablation study</h4><p>“&gt;[3]</span></a></sup></p><p>​        在表4中，我们比较了三个完整的ReGAT消融实例。 具体来说，我们验证了将问题特征连接到每个对象表示和注意力机制的重要性。 表4中报告的所有结果均基于BUTD模型架构。为了从关系编码器中消除注意力机制，我们只需将图注意力网络替换为图卷积网络，即可通过简单的线性变换从图中学习节点表示。</p><pre><code>      首先，我们验证了使用注意力机制学习关系感知视觉特征的有效性。 增加注意力机制会导致所有三种关系的准确性更高。 第1行和第2行的比较显示，语义关系的增益为+0.70，空间关系的增益为+0.81。 其次，我们验证了问题自适应关系特征的有效性。 在第1行和第3行之间，对于语义和空间关系，我们看到大约+0.1的增益。 最后，添加注意力机制和问题自适应功能以提供完整的ReGAT模型。 此实例的准确性最高（第4行）。 出乎意料的是，通过比较第1行和第4行，我们可以观察到，将图形注意力与问题自适应相结合，比简单地将两种方法的单个增益相加可获得更好的增益。 值得一提的是，对于隐式关系，添加问题自适应将模型性能提高+0.74，这比两个显式关系从问题自适应获得的收益要高。 考虑所有关系后，通过添加问题自适应机制，我们观察到了一致的性能提升。</code></pre><p>​        为了更好地理解这两个组件如何帮助回答问题，我们将在第4.5节中进一步可视化并比较通过消融实例获得的注意力图。</p><p><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT8.png" alt="img"></p><p>图4.从消融实例中学到的注意力图的可视化：每个图像中显示的三个边界框是前3个有人参与的区域。 数字是注意力权重。</p><h4 id="4-5-可视化"><a href="#4-5-可视化" class="headerlink" title="4.5 可视化"></a>4.5 可视化</h4><p>​        为了更好地说明添加图注意力和问题自适应机制的有效性，我们将完整ReGAT模型在单关系环境中学习的注意力图与两个消融模型中学习的注意力图进行了比较。 如图4所示，第二行，第三行和最后一行分别对应于表4中的第1行，第3行和第4行。将第2行与第3行进行比较可以发现，图形注意力有助于捕获对象之间的相互作用，这有助于以更好地对齐图像区域和问题。 第3行和第4行显示，添加问题自适应注意机制会产生更清晰的注意图，并关注更多相关区域。 这些可视化结果与表4中报告的定量结果一致。</p><p><img src="F:\BLOG_blog\hexoblog\themes\fluid\source\img\ReGAT9.png" alt="img"></p><p>图5. VQA任务中不同类型的可视对象关系的可视化。 每个图像中显示的3个边界框是前3个有人参与的区域。 绿色箭头指示对象之间的关系。 绿色框中的标签和数字是用于显式关系的类标签和用于隐式关系的注意权重。</p><p>​        图5提供了有关不同类型的关系如何帮助改善性能的可视化示例。 在每个示例中，我们显示了排名前三位的区域以及这些区域之间的学习关系。 如这些示例所示，每种关系类型都有助于更好地对齐图像区域和问题。 例如，在图5（a）中，语义关系“保持”和“骑行”与相应问题中出现的相同单词产生共鸣。 图5（b）显示了空间关系如何捕获区域之间的相对几何位置。</p><pre><code>  为了可视化隐式关系，图5（c）显示了从其他区域到前1个区域的注意力权重。 令人惊讶地，所学习的隐式关系能够捕获空间和语义交互。 例如，图5（c）的顶部图像显示了桌子和花瓶之间的空间互动，而底部图像显示了交通信号灯和人之间的语义互动。</code></pre><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5.  结论"></a><strong>5.</strong>  <strong>结论</strong></h3><p>​        我们提出了一种关系感知图注意力网络（ReGAT），这是一种用于视觉问题解答的新颖框架，用于通过具有问题自适应能力的注意力机制来建模多类型对象关系。 ReGAT 利用两种类型的可视对象关系：显式关系和隐式关系，以通过图形注意力学习关系型区域表示。 我们的方法在VQA 2.0和VQA-CP v2数据集上均达到了最新水平。 提出的ReGAT模型与通用VQA 模型兼容。 在两个VQA数据集上进行的综合实验表明，我们的模型可以即插即用的方式注入到最新的VQA体系结构中。 在以后的工作中，我们将研究如何更有效地融合这三个关系以及如何利用每个关系来解决特定的问题类型。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h3><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a><strong>六、参考</strong></h2><p><a href="https://blog.csdn.net/z704630835/article/details/108263031">https://blog.csdn.net/z704630835/article/details/108263031</a></p><p><a href="https://blog.csdn.net/xiasli123/article/details/102937712">https://blog.csdn.net/xiasli123/article/details/102937712</a></p><p><a href="https://zhuanlan.zhihu.com/p/63207928">https://zhuanlan.zhihu.com/p/63207928</a></p><p><a href="https://blog.csdn.net/weixin_42305378/article/details/103013846">https://blog.csdn.net/weixin_42305378/article/details/103013846</a></p><p><a href="https://blog.csdn.net/xiasli123/article/details/102937712?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">https://blog.csdn.net/xiasli123/article/details/102937712?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>较大的差异度，描述与场景<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>多层感知器(Multi-Layer Perceptron，MLP)<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>消融研究: 通常是指删除模型或算法的一些”功能”，并查看这如何影响性能。实际上ablation study就是为了研究模型中所提出的一些结构是否有效而设计的实验。比如你提出了某某结构，但是要想确定这个结构是否有利于最终的效果，那就要将去掉该结构的网络与加上该结构的网络所得到的结果进行对比，这就是ablation study<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>GAT</tag>
      
      <tag>图神经网络</tag>
      
      <tag>大创</tag>
      
      <tag>VQA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小憩</title>
    <link href="/2020/08/31/10001-%E5%B0%8F%E6%86%A9/"/>
    <url>/2020/08/31/10001-%E5%B0%8F%E6%86%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="小憩"><a href="#小憩" class="headerlink" title="小憩"></a>小憩</h1><p><img src="E:\blog\hexoblog\themes\fluid\source\img\10.png" alt="photo1"></p><p>&amp;      <strong>人生如棋，落子无悔</strong>。</p><p>​        人生就像一盘棋，一旦落子就不能反悔。过去也许有过荣耀，或许经历挫折，但都已不再重要。我们唯一能做的，就是<strong>走好脚下每一步</strong>，<strong>下好眼前每步棋</strong>，把每一个平凡的当下都努力过得精彩！</p><hr><p>&amp;      <strong>三四月做的事，七八月定会有答案</strong>。</p><p>​        与其抱怨不如争气，与其说做不下去，不如提升能力。你的实力才是你获得下一个机遇的资本和底气！  那些能在竞争中脱颖而出的人，往往都是因为他们比其他同行更愿意坚持，更愿意吃苦。所以，与其临渊羡鱼，不如退而结网。 </p><p>​     <strong>别再瞻前顾后，别再左右权衡，你的努力，时间都看得到。</strong></p><p>​    <strong>不必焦虑时光，也别心急终点；该播种时播种，该付出时付出。</strong></p><p>​    星光不问赶路人，时光不负有心人。</p><hr><p>&amp;       <strong>所谓的怀才不遇，其实只是怀才不够。</strong> </p><p>​         我们总以为，自己缺的是一鸣惊人的机会。却不明白，当才华配不上野心的时候，即便机会近在咫尺，也注定一败涂地。  所以，别再好高骛远，别再自怨自艾，在深渊时，耐心磨剑吧。 </p><hr><p>&amp;       <strong>别人只能看结果，自己要独撑过程。</strong> </p><p>​        你弱小时，所有人都敢对你指手画脚；你强大了，全世界都愿意对你和颜悦色。</p><p>​       所以，被打压时别愤怒，被忽视时别气馁，你只需悄悄地拔尖，然后惊艳所有人。</p><p>​      你要明白：学会向内归因，才会向外成长。</p><hr><p>&amp;      <strong>你以为自己药石无灵，但时间会让你久病成医。</strong>      </p><p>​         在百转千回的磨砺中，有无数个瞬间，我们伤痕累累，都以为自己药石无灵，但最后，时间却都让我们久病成医。 </p><p>​        别纠结眼前一城一池的输赢，别计较当下一砖一瓦的得失。</p><p>​        受过的伤，终成日后的铠甲；留下的疤，都是未来的勋章。</p><hr><p>&amp;     <strong>能给你遮风挡雨的，同样能让你不见天日。</strong> </p><p>​       人生路上，风雨飘摇，有枝可依是幸运，有力可扛是底气。可是，没有人会陪你一辈子，即使是你的影子，也会在黑暗时离开你。</p><p>​      苦要一口口吃，路要一步步走。<strong>世上最靠谱的捷径，永远是脚踏实地做自己。</strong></p><hr><p>&amp;    <strong>现在的你，就是过去积累的结果</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python实践——热力图</title>
    <link href="/2020/04/18/00011-python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    <url>/2020/04/18/00011-python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%83%AD%E5%8A%9B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="python实践——热力图"><a href="#python实践——热力图" class="headerlink" title="python实践——热力图"></a>python实践——热力图</h1><p>[TOC]</p><h4 id="2019全球海温热力图"><a href="#2019全球海温热力图" class="headerlink" title="2019全球海温热力图"></a>2019全球海温热力图</h4><ul><li>未调整温度及相关参数时：</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\4第四周\first.jpg" alt="first"></p><ul><li>调整数据及相关参数后：</li></ul><p>![heatmap  ](C:\Users\lenovo\Desktop\任务\4第四周\heatmap  .jpg)</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>sns.<span class="hljs-built_in">set</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadDatadet</span>(<span class="hljs-params">infile, k</span>):</span><br>    f = <span class="hljs-built_in">open</span>(infile, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    sourceInLine = f.readlines()<br>    dataset = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sourceInLine:<br>        temp1 = line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        temp2 = temp1.split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>        dataset.append(temp2)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            dataset[i].append(<span class="hljs-built_in">float</span>(dataset[i][j]))<br>        <span class="hljs-keyword">del</span>(dataset[i][<span class="hljs-number">0</span>:k])<br>    <span class="hljs-keyword">return</span> dataset<br><br><span class="hljs-string">&#x27;&#x27;&#x27;数据文件前期处理后存入num.txt&#x27;&#x27;&#x27;</span><br>infile=<span class="hljs-string">&#x27;C:\\Users\\lenovo\\DeskTop\\study\\num.txt&#x27;</span><br><br>k = <span class="hljs-number">360</span><br>infile = loadDatadet(infile, k)<br><br>uniform_data = np.array(infile)<br>ax = sns.heatmap(uniform_data, vmax=<span class="hljs-number">25</span>, cmap=<span class="hljs-string">&#x27;rainbow&#x27;</span>)<br><br>plt.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python实践——语音</title>
    <link href="/2020/04/16/00010-python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E8%AF%AD%E9%9F%B3/"/>
    <url>/2020/04/16/00010-python%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E8%AF%AD%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="python实践——语音"><a href="#python实践——语音" class="headerlink" title="python实践——语音"></a>python实践——语音</h1><h2 id="一、功能说明文档"><a href="#一、功能说明文档" class="headerlink" title="一、功能说明文档"></a>一、功能说明文档</h2><p>[TOC]</p><h4 id="主要功能——语音识别与搜索"><a href="#主要功能——语音识别与搜索" class="headerlink" title="主要功能——语音识别与搜索"></a>主要功能——语音识别与搜索</h4><ol><li><p><strong>选择语音种类</strong></p><p><code>choose language</code></p><p>提供五种选择,</p><p>在<code>Write Here</code>处，填写选项前的数字，</p><p>如：1537</p></li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">1537:普通话</span><br><span class="hljs-section">1737:英语</span><br><span class="hljs-section">1637:粤语</span><br><span class="hljs-section">1837:四川话</span><br><span class="hljs-section">1936:普通话远场 </span><br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>录音过程</strong></p><p>显示<code>Please speak...</code></p><p>大约5秒后，结束录音</p><p>显示<code>end</code></p></li></ol><ol start="3"><li><p><strong>音频识别阶段</strong></p><p>显示<code>Please wait...</code></p></li></ol><ol start="4"><li><p><strong>识别结果显示</strong></p><p>在<code>result</code>处，输出音频信息</p><p>如 示例1，西北工业大学</p></li></ol><ol start="5"><li><p><strong>搜索界面</strong></p><p>使用<code>webbrowser</code>指定浏览器并根据音频关键词展开搜索</p><p>输出信息同时，通过预先设定的搜索引擎（百度）展开搜索</p><p>跳出搜索后的网页界面</p></li></ol><ol start="6"><li><p><strong>继续识别选择</strong></p><p>界面显示<code>Try Again ?(y/n)</code></p></li></ol><ul><li>选择y， 则重复起始过程，选择语言，继续进行</li><li>选择n，退出操作</li></ul><h2 id="二、效果图"><a href="#二、效果图" class="headerlink" title="二、效果图"></a>二、效果图</h2><p>![pycharm界面](C:\Users\lenovo\Desktop\2020-04-16 (10).png)</p><p><img src="C:\Users\lenovo\Desktop\选择界面.jpg" alt="选择界面"></p><p>![示例1](C:\Users\lenovo\Desktop\2020-04-16 (11).png)</p><p>![示例2](C:\Users\lenovo\Desktop\2020-04-16 (12).png)</p><p>![示例3](C:\Users\lenovo\Desktop\2020-04-16 (13).png)</p><p><img src="C:\Users\lenovo\Desktop\选择y或n.jpg" alt="选择y或n"></p><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> wave<br><span class="hljs-keyword">from</span> pyaudio <span class="hljs-keyword">import</span> PyAudio, paInt16<br><span class="hljs-keyword">import</span> webbrowser<br><br><br>framerate = <span class="hljs-number">16000</span><br>num_samples = <span class="hljs-number">2000</span><br>channels = <span class="hljs-number">1</span><br>sampwidth = <span class="hljs-number">2</span><br>FILEPATH = <span class="hljs-string">&#x27;sound_test.wav&#x27;</span><br><br><br>base_url = <span class="hljs-string">&quot;https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s&quot;</span><br>APIKey = <span class="hljs-string">&quot;yG1NH4rUGgpQB6jTCsfIhLP9&quot;</span><br>SecretKey = <span class="hljs-string">&quot;CA8D90jCuZSGWmSCzXl84Z58eccev50G&quot;</span><br><br>HOST = base_url % (APIKey, SecretKey)<br><br><br><span class="hljs-comment"># 获取token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Token</span>(<span class="hljs-params">host</span>):</span><br>    res = requests.post(host)<br>    <span class="hljs-keyword">return</span> res.json()[<span class="hljs-string">&#x27;access_token&#x27;</span>]<br><br><br><span class="hljs-comment"># 保存音频文档</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wave_file</span>(<span class="hljs-params">filepath, data</span>):</span><br>    wf = wave.<span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>    wf.setnchannels(channels)<br>    wf.setsampwidth(sampwidth)<br>    wf.setframerate(framerate)<br>    wf.writeframes(<span class="hljs-string">b&#x27;&#x27;</span>.join(data))<br>    wf.close()<br><br><br><span class="hljs-comment"># 录音</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_record</span>():</span><br>    pa = PyAudio()<br>    stream = pa.<span class="hljs-built_in">open</span>(<span class="hljs-built_in">format</span>=paInt16, channels=channels,<br>                     rate=framerate, <span class="hljs-built_in">input</span>=<span class="hljs-literal">True</span>, frames_per_buffer=num_samples)<br>    my_buf = []<br>    t = time.time()<br>    print(<span class="hljs-string">&#x27;Please speak...&#x27;</span>)<br>    <span class="hljs-keyword">while</span> time.time() &lt; t + <span class="hljs-number">4</span>:<br>        string_audio_data = stream.read(num_samples)<br>        my_buf.append(string_audio_data)<br>    print(<span class="hljs-string">&#x27;end.&#x27;</span>)<br>    wave_file(FILEPATH, my_buf)<br>    stream.close()<br><br><br><span class="hljs-comment">#获取音频数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_audio</span>(<span class="hljs-params">file</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    <span class="hljs-keyword">return</span> data<br><br><br><span class="hljs-comment">#上传音频文件</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sound_text</span>(<span class="hljs-params">speech_data, token, dev_pid=<span class="hljs-number">1537</span></span>):</span><br>    FORMAT = <span class="hljs-string">&#x27;wav&#x27;</span><br>    RATE = <span class="hljs-string">&#x27;16000&#x27;</span><br>    CHANNEL = <span class="hljs-number">1</span><br>    CUID = <span class="hljs-string">&#x27;sound_test&#x27;</span><br>    SPEECH = base64.b64encode(speech_data).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    data = &#123;<br>        <span class="hljs-string">&#x27;format&#x27;</span>: FORMAT,<br>        <span class="hljs-string">&#x27;rate&#x27;</span>: RATE,<br>        <span class="hljs-string">&#x27;channel&#x27;</span>: CHANNEL,<br>        <span class="hljs-string">&#x27;cuid&#x27;</span>: CUID,<br>        <span class="hljs-string">&#x27;len&#x27;</span>: <span class="hljs-built_in">len</span>(speech_data),<br>        <span class="hljs-string">&#x27;speech&#x27;</span>: SPEECH,<br>        <span class="hljs-string">&#x27;token&#x27;</span>: token,<br>        <span class="hljs-string">&#x27;dev_pid&#x27;</span>: dev_pid<br>    &#125;<br>    url = <span class="hljs-string">&#x27;https://vop.baidu.com/server_api&#x27;</span><br>    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br>    print(<span class="hljs-string">&#x27;Please wait...&#x27;</span>)<br>    print(<span class="hljs-string">&quot;result:&quot;</span>)<br>    r = requests.post(url, json=data, headers=headers)<br>    Result = r.json()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;result&#x27;</span> <span class="hljs-keyword">in</span> Result:<br>        <span class="hljs-keyword">return</span> Result[<span class="hljs-string">&#x27;result&#x27;</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> Result<br><br><span class="hljs-comment"># 连接浏览器进行搜索</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">openbrowser</span>(<span class="hljs-params">text</span>):</span><br>    webbrowser.open_new_tab(<span class="hljs-string">&#x27;https://www.baidu.com/s?wd=%s&#x27;</span> % text)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    tick = <span class="hljs-string">&#x27;y&#x27;</span><br>    <span class="hljs-keyword">while</span> tick.lower() == <span class="hljs-string">&#x27;y&#x27;</span>:<br>        print(<span class="hljs-string">&#x27;Please choose language ：&#x27;</span>)<br>        devpid = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;1537:普通话\n1737:英语\n1637:粤语\n1837:四川话\n1936:普通话远场\n     Write Here : &#x27;</span>)<br>        get_record()<br>        TOKEN = get_Token(HOST)<br>        speech = get_audio(FILEPATH)<br>        result = sound_text(speech, TOKEN, <span class="hljs-built_in">int</span>(devpid))<br>        print(result)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(result) == <span class="hljs-built_in">str</span>:<br>            openbrowser(result.strip(<span class="hljs-string">&#x27;，&#x27;</span>))<br>        tick = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Try Again ?(y/n):&#x27;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习</title>
    <link href="/2020/04/15/00006-python%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/04/15/00006-python%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><p>[TOC]</p><h3 id="1、python特点"><a href="#1、python特点" class="headerlink" title="1、python特点"></a>1、python特点</h3><ul><li><p>创作者</p><p> Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。 </p></li><li><p>特点：</p><p> “优雅”、“明确”、“简单” </p></li><li><p>缺点 ：</p><ul><li>运行速度慢 ，因为 Python是解释型语言 </li><li> 代码不能加密 </li></ul></li></ul><h3 id="2、安装python"><a href="#2、安装python" class="headerlink" title="2、安装python"></a>2、安装python</h3><ul><li>（之前已经安装python3.7.2）</li></ul><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1586767233346.png" alt="1586767233346"></p><ul><li><p> 输入<code>exit()</code>并回车，退出Python交互式环境，或者直接关掉命令行窗口 </p></li><li><p>python解释器</p><p>（之前已安装pycharm）</p><ul><li><p>CPython</p><p>  CPython是使用最广的Python解释器 ,是用C语言开发的 ，用<code>&gt;&gt;&gt;</code>作为提示符 </p></li><li><p>IPython</p><p> IPython是基于CPython之上的一个交互式解释器 ， IPython用<code>In [序号]:</code>作为提示符 </p></li><li><p>PyPy</p><p> 对Python代码进行动态编译 ， 显著提高Python代码的执行速度</p></li><li><p>Jython</p><p> 运行在Java平台上的Python解释器 </p></li><li><p>IronPython</p><p> 是运行在微软.Net平台上的Python解释器 </p></li></ul></li></ul><h3 id="3、第一个python程序"><a href="#3、第一个python程序" class="headerlink" title="3、第一个python程序"></a>3、第一个python程序</h3><h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><p>Windows 开始菜单处“命令提示符”，进入命令行模式</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1586767972224.png" alt="1586767972224"></p><h5 id="Python交互模式"><a href="#Python交互模式" class="headerlink" title="Python交互模式"></a>Python交互模式</h5><p>命令行 模式下敲命令<code>python</code> ， 进入到Python交互模式</p><p>按<code>exit()</code>退出Python交互模式，回到命令行模式 </p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1586767831621.png" alt="1586767831621"></p><h5 id="执行一个-py文件"><a href="#执行一个-py文件" class="headerlink" title="执行一个.py文件"></a>执行一个<code>.py</code>文件</h5><p>   执行一个<code>.py</code>文件<em>只能</em>在命令行模式执行 ，而且 必须先把  当前目录切换到<code>hello.py</code>所在的目录下，才能正常执行</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1586768710347.png" alt="1586768710347"></p><ul><li>Python交互式环境下，可以直接得到结果，但是在命令行执行<code>.py</code>时，需要代码中<code>print（）</code></li></ul><p>  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1586768355262.png" alt="1586768355262"></p><h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><ul><li><p>输出</p><p> 用<code>print()</code>在括号中加上字符串 </p><p> 也可以接受多个字符串，用逗号“,”隔开，就会连成一串输出 ，其中逗号“,”会输出一个空格 </p></li><li><p>输入</p><p> Python提供了一个<code>input()</code>，可以让用户输入字符串，并存放到一个变量里 ，之后， 直接输入<code>name</code>查看变量内容 ，或者 还可以用<code>print()</code>函数 </p></li></ul><h3 id="4、Python基础"><a href="#4、Python基础" class="headerlink" title="4、Python基础"></a>4、Python基础</h3><p>​         当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块； 使用<em>4个空格</em>的缩进 ；区分大小写</p><h5 id="数据类型与变量"><a href="#数据类型与变量" class="headerlink" title="数据类型与变量"></a>数据类型与变量</h5><ul><li><p>整数  </p><p>Python可以处理任意大小的整数，包括负整数，在程序中的表示方法和数学上的写法相同， 用以<code>0x</code>前缀 十六进制表示整数比较方便 </p></li><li><p>浮点数</p><p> 对于很大或很小的浮点数，须用科学计数法表示，把10用e替代 </p><p>！ 整数运算精确 ， 浮点数运算则可能会有四舍五入的误差 </p></li><li><p>字符串</p><ul><li> 四种字符串表示</li></ul><p>​            ‘ ’        “ ”            ‘’’ ‘’’              “””  “””</p><ul><li><p>用转义字符<code>\</code>来标识 内容里的引号</p><p>有很多字符都需要转义时，Python允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义 </p><p>字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容， </p></li></ul></li><li><p>布尔值</p><ul><li><p>只有<code>True</code>、<code>False</code>两种值 </p></li><li><p>布尔值可以用  与或非  <code>and</code>、<code>or</code>和<code>not</code>运算 </p></li><li><p> 布尔值经常用在条件判断中 </p></li></ul></li><li><p>空值</p><p> 用<code>None</code>表示，<code>None</code>不能理解为<code>0</code>，<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值</p></li><li><p>变量</p><ul><li><p>变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头 </p></li><li><p>变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，会报错。 </p></li></ul></li><li><p>常量</p><ul><li> 在Python中，通常用全部大写的变量名表示常量</li></ul></li></ul><h5 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h5><ul><li><p>ASCII编码和Unicode编码的区别：</p><p>ASCII编码是1个字节，而Unicode编码通常是2个字节</p></li><li><p> 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码 </p></li><li><p><code>ord()</code>函数获取字符的整数表示</p><p><code>chr()</code>函数把编码转换为对应的字符 </p></li></ul><p>  ​          <em>如下是chr（）出的星座符号</em>：</p><p>​                  ♈♉♊♋♌♍♎♏♐♑♒♓</p><ul><li><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示 </p><ul><li> 区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节 </li><li> 以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code> </li><li> 当<code>str</code>和<code>bytes</code>互相转换时，需要指定编码。最常用的编码是<code>UTF-8</code> </li></ul></li><li><p>格式化</p><ul><li> <code>%</code>运算符就是用来格式化字符串的 </li><li>  使用 format() 格式化字符串 ， 传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>…… </li></ul></li></ul><table><thead><tr><th align="left">%运算符</th><th align="left">替换内容</th></tr></thead><tbody><tr><td align="left">%d</td><td align="left">整数</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%s</td><td align="left">字符串</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr></tbody></table><p>​          </p><h5 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h5><ul><li><p>list</p><ul><li><p>list是一种有序的集合，可以随时添加和删除其中的元素。 </p></li><li><p>使用方括号[]或list（）创建，元素间用逗号分隔</p></li><li><p>列表中各元素类型可以不同，无长度限制</p></li><li><p> 用<code>len()</code>函数可以获得list元素的个数 </p></li><li><table><thead><tr><th>函数或方法</th><th>描述</th></tr></thead><tbody><tr><td>ls[i] = x</td><td>替换列表ls第i元素为x</td></tr><tr><td>Is[i:j:k]=It</td><td>用列表lt替换ls切片后所对应元素子列表</td></tr><tr><td>del ls[i]</td><td>删除列表Is中第i元素</td></tr><tr><td>del Is[i:j:k]</td><td>删除列表ls中第i到第j以k为步长的元素</td></tr><tr><td>ls += lt</td><td>更新列表Is，将列表lt元素增加到列表ls中</td></tr><tr><td>ls *= n</td><td>更新列表Is，其元素重复n次</td></tr><tr><td>Is.append(x)</td><td>在列表ls后增加一个元素</td></tr><tr><td>Is.clear()</td><td>删除列表ls中所有元素</td></tr><tr><td>Is.copy()</td><td>生成一个新列表，赋值Is中所有元素</td></tr><tr><td>Is.insert(i,x)</td><td>在列表Is的第i位置增加元素x</td></tr><tr><td>Is.pop(i)</td><td>将列表ls中第i位置元素取出并删除该元素</td></tr><tr><td>Is.remove(x)</td><td>将列表Is中出现的第一个元素×删除</td></tr><tr><td>Is.reverse()</td><td>将列表ls中的元素反转</td></tr></tbody></table></li></ul></li></ul><ul><li> 用索引来访问list中每一个位置的元素 ，正向从0递增，也可以反向从-1递减</li><li> 当索引超出了范围时，Python会报一个<code>IndexError</code>错误，故要确保索引不要越界，最后一个元素的索引是<code>len(classmates) - 1</code>。 </li></ul><ul><li><p>tuple</p><ul><li><p>list是一种序列类型，一旦创建就不能修改</p></li><li><p>使用小括号（）或  tuple（）创建，元素间用逗号分隔</p></li><li><p>可以使用或不使用小括号，但是只有一个元素时，为避免歧义， 必须加其后一个逗号<code>,</code> </p></li></ul></li></ul><h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><ul><li><p>形式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">if <span class="hljs-params">&lt;条件判断<span class="hljs-number">1</span>&gt;</span>:<br>    <span class="hljs-params">&lt;执行<span class="hljs-number">1</span>&gt;</span><br>elif <span class="hljs-params">&lt;条件判断<span class="hljs-number">2</span>&gt;</span>:<br>    <span class="hljs-params">&lt;执行<span class="hljs-number">2</span>&gt;</span><br>elif <span class="hljs-params">&lt;条件判断<span class="hljs-number">3</span>&gt;</span>:<br>    <span class="hljs-params">&lt;执行<span class="hljs-number">3</span>&gt;</span><br><span class="hljs-symbol">else:</span><br>    <span class="hljs-params">&lt;执行<span class="hljs-number">4</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>input（）</p><p> <code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数 ，</p><p>可以用 <code>int()</code>函数 </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s</span> = input(<span class="hljs-string">&#x27;birth: &#x27;</span>)<br><span class="hljs-attr">birth</span> = int(s)<br></code></pre></td></tr></table></figure><p>也可以用eval（）函数</p></li></ul><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><ul><li><p>for…in… 遍历循环</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf">for <span class="hljs-attribute">&lt;循环变量&gt;</span> in <span class="hljs-attribute">&lt;遍历结构&gt;</span>:<br><span class="hljs-attribute">&lt;语句块&gt;</span><br></code></pre></td></tr></table></figure></li><li><p> while   循环</p></li><li><p><code>range()</code>函数 ： 如<code>range(N)</code>生成的序列是从0开始小于N的整数 </p></li><li><p>break： <code>break</code>语句 提前退出循环 ，只跳出内层循环，外层循环仍然有效</p></li><li><p>continue： 通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环 </p></li><li></li><li><p> <code>Ctrl+C</code>  退出程序 </p></li></ul><h5 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h5><ul><li><p>dict  </p><ul><li><p> 字典：dict，也称为map，使用键-值（key-value）存储，具有极快的查找速度</p></li><li><p>字典类型是”映射”的体现 ．</p><p>键值对：键是数据索引的扩展 ．</p><p>字典是键值对的集合，键值对之间无序 ·</p><p>采用大括号{}和dict()创建，键值对用冒号：表示 {&lt;键1&gt;：&lt;值1&gt;，&lt;键2&gt;：&lt;值2&gt;， &lt;键n&gt;:&lt;值n&gt;} </p></li><li><p> 多次对一个key放入value，后面的值会把前面的值冲掉 </p></li><li><p> dict的key必须是不可变对象， 字符串、整数等都是不可变的，可以作为key；而list是可变的，不能作为key </p></li><li><p>如果key不存在，dict就会报错 ，解决：</p><p> 一是通过<code>in</code>判断key是否存在</p><p> 二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value </p></li><li><p>函数方法</p><p>​     <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="函数方法">  </p></li></ul></li><li><p>set</p><ul><li><p>集合元素不可更改，不能是可变数据类型， 在set中，没有重复的key， 可以重复添加，但不会有效果 </p></li><li><p>集合是多个元素的无序组合 ．</p><p>集合用大括号{}表示，元素间用逗号分隔 </p><p>建立集合类型用{}或set{} ．</p><p>建立空集合类型，必须使用set{}</p></li><li><p>操作符</p><table><thead><tr><th>操作函数或方法</th><th>描述</th></tr></thead><tbody><tr><td>S.add(x)</td><td>如果不在集合S中，将x加到S</td></tr><tr><td>S.discard(x)</td><td>移除S中元素x，如不在集合s中，不报错</td></tr><tr><td>S.remove(x)</td><td>移除S中元素x，如不在集合s中，报错KeyError</td></tr><tr><td>S.clear()</td><td>移除S中所有元素</td></tr><tr><td>S.pop()</td><td>随机返回S的一个元素，跟新S，若S为空产生KeyError</td></tr><tr><td>S.copy()</td><td>返回集合S的一个副本</td></tr><tr><td>len(S)</td><td>返回集合S的元素个数</td></tr><tr><td>x in S</td><td>判断S中元素×，×在集合S中，返回True，否则返回False</td></tr><tr><td>x not in S</td><td>判断S中元素×，x不在集合S中，返回True，否则返回False</td></tr><tr><td>set(x)</td><td>将其他类型变量×转变为集合类型</td></tr></tbody></table><p>​      </p></li></ul></li></ul><h3 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h3><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><ul><li><p> 交互式命令行通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息 </p></li><li><p>数据类型转换</p><p> <code>int()</code>函数可以把其他数据类型转换为整数 </p><p><code>float()</code>转化为浮点型</p><p><code>str()</code>转化为字符串</p><p><code>bool()</code></p></li><li><p>函数名其实就是指向一个函数对象的引用，也可以把函数名赋给一个变量，相当于给这个函数起了一个“别名” </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = abs <span class="hljs-comment"># 变量a指向abs函数</span><br></code></pre></td></tr></table></figure><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5></li><li><p>形式</p></li></ul><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bnf">def<span class="hljs-attribute">&lt;函数名&gt;</span>（<span class="hljs-attribute">&lt;参数（0个或多个）&gt;</span>）： <br><span class="hljs-attribute">&lt;函数体&gt;</span> <br>return<span class="hljs-attribute">&lt;返回值&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>空函数</p><p> 如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句 ， <code>pass</code>可以用来作为占位符，先放一个<code>pass</code>，让代码能够运行 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nop</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span><br>    pass<br></code></pre></td></tr></table></figure></li><li><p>参数检查</p><ul><li><p> 如果有必要，可以先对参数的数据类型做检查 </p></li><li><p> 调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code></p></li></ul></li><li><p>返回多个值</p><ul><li><p>函数体内部可以用<code>return</code>随时返回函数结果</p><p>函数执行完毕也没有<code>return</code>语句时，自动<code>return None</code></p></li><li><p>Python的函数返回多值,实质是返回一个tuple</p></li></ul></li></ul><h5 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h5><ul><li><p>位置参数</p></li><li><p>默认参数（可选参数）</p><p>可选参数放在必选参数后面</p><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数 </p><p><em>定义默认参数要牢记一点：默认参数必须指向不变对象</em></p></li><li><p>可变参数</p><pre><code>* 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数*  如果已经有一个list或者tuple，要调用一个可变参 数， 允许在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去 </code></pre></li><li><p>关键字参数 </p><ul><li><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">person</span>(<span class="hljs-params">name, age, **kw</span>):</span><br>    print(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>命名关键字参数</p><ul><li> 和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数 </li><li> 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code> </li><li> 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错 </li><li> 名关键字参数可以有缺省值，从而简化调用 ， 命名关键字参数具有默认值，调用时，可不传入此参数 </li><li> 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数 </li></ul></li></ul><ul><li><p>参数组合</p><ul><li> 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 </li><li> 对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用 </li></ul></li><li><p>注意：</p><ul><li>注意定义可变参数和关键字参数的语法：</li></ul><p>​     <code>*args</code>是可变参数，args接收的是一个tuple；</p><p>   <code>**kw</code>是关键字参数，kw接收的是一个dict。</p><ul><li><p>调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)</code></p></li><li><p> 定义命名的关键字参数在没有可变参数的情况下记得写分隔符<code>*</code>，否则定义的将是位置参数 </p></li></ul></li></ul><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><ul><li>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</li><li>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</li><li>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</li></ul><h3 id="6、高级特性"><a href="#6、高级特性" class="headerlink" title="6、高级特性"></a>6、高级特性</h3><h5 id="切片（Slice）"><a href="#切片（Slice）" class="headerlink" title="切片（Slice）"></a>切片（Slice）</h5><ul><li><p>L[a  :  b ：c]      表示，从索引<code>a</code>开始取，直到索引<code>b</code>为止，但不包括索引<code>b</code> ，步长为<code>c</code>,<code>a、b</code>可以省略</p></li><li><p> 也支持倒数切片 ，倒数第一个索引为-1</p></li><li><p>L <code>[:]</code>    复制一个list </p></li><li><p>元组、字符串也可以切片，操作结果还是元组、字符串</p></li></ul><h5 id="迭代（Iteration）"><a href="#迭代（Iteration）" class="headerlink" title="迭代（Iteration）"></a>迭代（Iteration）</h5><ul><li><p> 给定一个list或tuple，可以通过<code>for</code>循环遍历这个list或tuple，称为迭代 </p></li><li><p>dict</p><ul><li><p>迭代key，<code>for key in d:</code></p></li><li><p> 迭代value，可以用<code>for value in d.values()</code> </p></li><li><p> 同时迭代key和value，可以用<code>for k, v in d.items()</code> </p></li></ul></li><li><p> 使用<code>for</code>循环时，只要作用于一个可迭代对象，<code>for</code>循环就可以正常运行，不太关心该对象究竟是list还是其他数据类型 </p></li><li><p>判断一个对象是可迭代对象 : 通过collections模块的Iterable类型判断 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">from</span> collections import <span class="hljs-keyword">Iterable</span><br>isinstance(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-keyword">Iterable</span>) <span class="hljs-comment"># str是否可迭代</span><br></code></pre></td></tr></table></figure></li><li><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，可以在<code>for</code>循环中同时迭代索引和元素本身 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">i</span>, <span class="hljs-selector-tag">value</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">enumerate</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]):<br><span class="hljs-selector-tag">print</span>(i, value)<br></code></pre></td></tr></table></figure><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5></li><li><p><code>list(range(a, b))</code>    生成从a到b的列表，包括a不包括b</p></li><li><p><code> [x * x for x in range(1, 11)]</code>      生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环 </p></li><li><p><code>[x * x for x in range(1, 11) if x % 2 == 0]</code>     if判断 ,做出 筛选 </p></li><li><p><code> [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code>    两层循环，生成全排列 </p></li><li><p> <code> [k + &#39;=&#39; + v for k, v in d.items()]</code>      使用两个变量来生成list </p></li><li><p><code>[s.lower() for s in L]</code> list中所有的字符串变成小写 </p></li><li><p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code> </p><ul><li><code>[x if x % 2 == 0 else -x for x in range(1, 11)]</code></li><li><code> [x for x in range(1, 11) if x % 2 == 0]</code></li></ul></li></ul><h5 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 ( generator )"></a>生成器 ( generator )</h5><ul><li><p>创建了一个generator :</p><ul><li>把一个列表生成式的<code>[]</code>改成<code>()</code> </li><li> 如果一个函数定义中包含<code>yield</code>关键字 </li></ul></li></ul><ul><li><p>打印 generator的每一个元素 ：</p><ul><li> 通过<code>next()</code>函数 </li><li> <code>for</code>循环 （ generator也是可迭代对象 ）</li></ul></li><li><p>  区分普通函数和generator函数，普通函数调用直接返回结果 ，generator函数的“调用”实际返回一个generator对象 </p></li></ul><h5 id="迭代器（-Iterator-）"><a href="#迭代器（-Iterator-）" class="headerlink" title="迭代器（ Iterator ）"></a>迭代器（ Iterator ）</h5><ul><li>可迭代对象：<code>Iterable</code>       可以直接作用于<code>for</code>循环的对象 </li></ul><p>​        迭代器：<code>Iterator</code>        可以作用于<code>for</code>循环 ，也可以被<code>next()</code>函数调用并不断返回下一个值的对象 </p><p>​         可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象 </p><p>​        可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象 </p><ul><li><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>    ， 使用<code>iter()</code>函数</p></li><li><p> Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误 </p></li><li><p> <code>Iterator</code>的计算 ， 只有在需要返回下一个数据时它才会计算</p></li></ul><h3 id="7、函数式编程"><a href="#7、函数式编程" class="headerlink" title="7、函数式编程"></a>7、函数式编程</h3><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><ul><li><p>变量可以指向函数</p><p><code>f = abs</code>   变量<code>f</code>指向了<code>abs</code>函数本身，直接调用<code>abs()</code>函数和调用变量<code>f()</code>完全相同 ，f相当于abs的小名</p></li><li><p>函数名也是变量</p><p>（ <code>abs</code>函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改<code>abs</code>变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code> ）</p></li><li><p>传入函数</p><p> 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式 </p></li></ul><h6 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h6><ul><li><p><code>map()</code>函数</p><p>接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>):</span><br><span class="hljs-keyword">return</span> x * x<br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br><span class="hljs-built_in">list</span>(r)<br>&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p> <code>map()</code>作为高阶函数，事实上它把运算规则抽象 ， 还可以计算任意复杂的函数 </p></li><li><p><code>reduce（）</code></p><p>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算 :</p><p><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">reduce</span><span class="hljs-params">(add, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])</span></span>    <span class="hljs-comment">//序列求和</span><br></code></pre></td></tr></table></figure><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6></li><li><p> <code>filter()</code>函数用于过滤序列 </p></li><li><p> 和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素 </p></li></ul><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h6><ul><li> <code>sorted()</code>函数可以对list进行排序 </li><li> <code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序 ， key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序 </li><li> <code> sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)</code>     进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code> </li></ul><h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><ul><li>函数作为返回值</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy_sum</span><span class="hljs-params">(*args)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span><br>        ax = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-symbol">args:</span><br>            ax = ax + n<br>        <span class="hljs-keyword">return</span> ax<br>    <span class="hljs-keyword">return</span> sum<br>f = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><p> 在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中 ，此被称为“闭包”</p><ul><li>闭包<ul><li> 返回闭包时牢记：返回函数不要引用任何循环变量，或者后续会发生变化的变量</li></ul></li></ul><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p><code> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</code></p><ul><li> 匿名函数<code>lambda x: x * x</code>   , 关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数 </li><li> 匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果 </li><li> 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数 , 也可以把匿名函数作为返回值返回 </li></ul><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><ul><li> 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） </li><li> 本质上，decorator就是一个返回函数的高阶函数 </li></ul><h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><ul><li><p> 偏函数（Partial function） </p></li><li><p> <code>functools.partial </code>  创建一个偏函数 , 把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单 </p></li></ul><h3 id="8、模块"><a href="#8、模块" class="headerlink" title="8、模块"></a>8、模块</h3><ul><li><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用 </p></li><li><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行<code>import abc</code>，若成功则说明系统存在此模块。</li></ul></li></ul><h5 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h5><ul><li><p>Python模块的标准文件模板 </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#!/usr/bin/env python3</span><br><span class="hljs-meta"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&#x27; a test module &#x27;</span><br><br>__author__ = <span class="hljs-string">&#x27;name&#x27;</span><br><br></code></pre></td></tr></table></figure></li><li><p>方法：</p><ul><li><p>导入模块</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sys<br></code></pre></td></tr></table></figure></li></ul></li><li><p> 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public </p></li><li><p>作用域</p><ul><li> 类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</li><li> 类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，自己的变量一般不要用这种变量名  </li><li> 正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等； </li></ul></li></ul><h5 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h5><ul><li><p> 在Python中，安装第三方模块，是通过包管理工具pip完成 </p></li><li><p>安装常用模块</p><p> <code>Anaconda</code> 一个基于Python的数据处理和科学计算平台，内置了许多非常有用的第三方库 </p></li><li><p>模块搜索路径</p><p> 添加搜索目录的两种方法 ：</p><ul><li><p>直接修改<code>sys.path</code>，添加要搜索的目录： </p><p>（ 运行时修改，运行结束后失效 ）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">import</span> sys<br>sys.<span class="hljs-built_in">path</span>.append(<span class="hljs-string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p> 设置环境变量<code>PYTHONPATH</code>，环境变量的内容会被自动添加到模块搜索路径中 </p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS</title>
    <link href="/2020/04/12/00009-ROS%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/04/12/00009-ROS%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS学习"><a href="#ROS学习" class="headerlink" title="ROS学习"></a>ROS学习</h1><p>[TOC]</p><h3 id="1、安装并配置ROS环境"><a href="#1、安装并配置ROS环境" class="headerlink" title="1、安装并配置ROS环境"></a>1、安装并配置ROS环境</h3><ul><li><p>安装ROS</p></li><li><p>管理环境</p><ul><li>检查已设置环境变量</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">$ printenv <span class="hljs-string">| grep ROS</span><br></code></pre></td></tr></table></figure><img src="C:\Users\lenovo\Desktop\ros\IMG_20200408_081252.jpg" alt="IMG_20200408_081252" style="zoom:50%;" /></li></ul><ul><li><p>每次打开终端前<code>source</code>命令</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">source</span> <span class="hljs-regexp">/opt/</span>ros<span class="hljs-regexp">/kinetic/</span>setup.bash<br></code></pre></td></tr></table></figure></li><li><p>（也可以事先在 <code>.bashrc</code>文件中添加这条命令，以便每次登录后系统已经帮你执行这些命令配置好环境。） </p></li><li><p>创建ROS工作空间</p><ul><li><p>创建一个 catkin 工作空间</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>mkdir -p ~<span class="hljs-regexp">/catkin_ws/src</span><br><span class="hljs-variable">$ </span>cd ~<span class="hljs-regexp">/catkin_ws/src</span><br><span class="hljs-variable">$ </span>catkin_make<br></code></pre></td></tr></table></figure></li><li><p><code>source</code> 一下新生成的 setup.*sh 文件： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> devel/setup.bash</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200408_214919.jpg" alt="IMG_20200408_214919"></p></li></ul></li></ul><ul><li><p>确保<code>ROS_PACKAGE_PATH</code>环境变量包含你的工作空间目录，采用以下命令查看： </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>echo <span class="hljs-variable">$ROS_PACKAGE_PATH</span><br>/home/&lt;youruser&gt;<span class="hljs-regexp">/catkin_ws/src</span><span class="hljs-symbol">:/opt/ros/kinetic/share</span><br></code></pre></td></tr></table></figure><h3 id="2、ROS文件系统介绍"><a href="#2、ROS文件系统介绍" class="headerlink" title="2、ROS文件系统介绍"></a>2、ROS文件系统介绍</h3></li><li><p>安装ros_tutorials软件包</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-builtin-name">get</span> install ros-kinetic-ros-tutorials<br></code></pre></td></tr></table></figure><img src="C:\Users\lenovo\Desktop\ros\IMG_20200408_215558.jpg" alt="IMG_20200408_215558" style="zoom:67%;" /></li></ul><ul><li><p>快速了解文件系统概念</p><p><strong>Packages:</strong> 软件包，是ROS应用程序代码的组织单元，每个软件包都可以包含程序库、可执行文件、脚本或者其它手动创建的东西。 </p><p><strong>Manifest (package.xml):</strong> 清单，是对于’软件包’相关信息的描述,用于定义软件包相关元信息之间的依赖关系，这些信息包括版本、维护者和许可协议等。 </p></li><li><p>文件系统工具</p><ul><li><p>使用 rospack</p><p>允许你获取软件包的有关信息 。 <code>rospack</code>中<code>find</code>参数选项可以返回软件包的路径信息。 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># rospack find [包名称]  以下为例子：</span><br>$ rospack <span class="hljs-builtin-name">find</span> roscpp<br></code></pre></td></tr></table></figure><img src="C:\Users\lenovo\Desktop\ros\IMG_20200408_215748.jpg" alt="IMG_20200408_215748" style="zoom:67%;" /></li></ul></li></ul><ul><li><p>使用 roscd</p><p>是rosbash命令集中的一部分，允许直接切换（cd）工作目录到某个软件包或者软件包集当中。 </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># roscd [本地包名称[/子目录]]  以下为例子：</span><br><span class="hljs-variable">$ </span>roscd roscpp<br></code></pre></td></tr></table></figure><p> <code>roscd</code>只能切换到那些路径已经包含在 <code>ROS_PACKAGE_PATH</code>环境变量中的软件包，要查看 <code>ROS_PACKAGE_PATH</code> 中包含的路径可以输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span></span><br></code></pre></td></tr></table></figure></li><li><p>roscd log</p><p>切换到 ROS 保存日记文件的目录下 </p></li><li><p>使用 rosls</p><p><code>rosls</code>是 <code>rosbash</code>命令集中的一部分，允许直接按软件包的名称而不是绝对路径执行 <code>ls</code>命令</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> rosls [本地包名称[/子目录]]  <br><span class="hljs-symbol">$</span> rosls roscpp_tutorials<br></code></pre></td></tr></table></figure></li></ul><p>  <img src="C:\Users\lenovo\Desktop\ros\IMG_20200408_220307.jpg" alt="IMG_20200408_220307"></p><ul><li><p>Tab 自动补全</p><p>按<strong>TAB</strong>键后，命令行中应该会自动补充剩余部分,再次按 <strong>TAB</strong> 键后应该会列出所有以 <code>turtle</code> 开头的 ROS 软件包 </p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf">$ roscd roscpp_tut<span class="hljs-attribute">&lt;&lt;&lt; 现在请按TAB键 &gt;</span>&gt;&gt;<br>$ rosls <span class="hljs-attribute">&lt;&lt;&lt; 请按两次 TAB 键 &gt;</span>&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="3、创建ROS程序包"><a href="#3、创建ROS程序包" class="headerlink" title="3、创建ROS程序包"></a>3、创建ROS程序包</h3></li><li><p>一个catkin程序包由什么组成</p><p>​     该程序包必须包含catkin compliant package.xml文件 </p><p>​     程序包必须包含一个catkin 版本的CMakeLists.txt文件，而Catkin metapackages中必须包含一个对CMakeList.txt文件的引用。 </p><p>​     每个目录下只能有一个程序包 </p></li><li><p>创建一个catkin程序包</p><p>使用catkin_create_pkg命令来创建一个新的catkin程序包 </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ cd ~<span class="hljs-regexp">/catkin_ws/</span>src<br></code></pre></td></tr></table></figure><p>使用catkin_create_pkg命令来创建一个名为’beginner_tutorials’的新程序包</p><p>这个程序包依赖于std_msgs、roscpp和rospy：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>catkin_create_pkg beginner_tutorials std_msgs rospy roscpp<br></code></pre></td></tr></table></figure></li><li><p>程序包依赖关系</p><ul><li><p>一级依赖</p><p>使用rospack命令工具来查看一级依赖包。 </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rospack depends1 beginner_tutorials<br></code></pre></td></tr></table></figure></li><li><p>间接依赖</p><p>在很多情况中，一个依赖包还会有它自己的依赖包，比如rospy还有其它依赖包。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rospack depends1 rospy<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>  <img src="C:\Users\lenovo\Desktop\ros\IMG_20200409_202256.jpg" alt="IMG_20200409_202256"></p><ul><li><p>一个程序包还可以有好几个间接的依赖包，使用rospack可以递归检测出所有的依赖包。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rospack depends beginner_tutorials<br></code></pre></td></tr></table></figure><img src="C:\Users\lenovo\Desktop\ros\IMG_20200409_203008.jpg" alt="IMG_20200409_203008" style="zoom:50%;" /></li></ul><ul><li><p>自定义你的程序包</p><ul><li><p>自定义 package.xml</p><ul><li><p>描述标签</p><p>更新描述标签：</p><p><code> &lt;description&gt;The beginner_tutorials package&lt;/description&gt;</code></p></li><li><p>维护者标签</p><p>至少需要填写一个维护者名称 </p><p><code> &lt;maintainer email=&quot;you@yourdomain.tld&quot;&gt;Your Name&lt;/maintainer&gt;</code></p></li><li><p>许可标签</p><p>选择一种许可协议比如BSD</p><p><code>&lt;license&gt;BSD&lt;/license&gt;</code></p></li><li><p>依赖项标签</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">build_depend</span><br><span class="hljs-keyword">buildtool_depend</span><br><span class="hljs-keyword">run_depend</span><br><span class="hljs-keyword">test_depend</span><br></code></pre></td></tr></table></figure></li><li><p>最后完成的 package.xml</p><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200409_212801.jpg" alt="IMG_20200409_212801"></p></li></ul></li><li><p>自定义 CMakeLists.txt</p></li></ul></li></ul><h3 id="4、编译ROS程序包"><a href="#4、编译ROS程序包" class="headerlink" title="4、编译ROS程序包"></a>4、编译ROS程序包</h3><ul><li><p>使用catkin_make</p><p>catkin_make 是一个命令行工具，它简化了catkin的标准工作流程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> catkin_make   （此命令会编译src文件夹下的所有catkin工程）</span><br><span class="hljs-meta">$</span><span class="bash"> catkin_make --<span class="hljs-built_in">source</span> my_src</span><br></code></pre></td></tr></table></figure></li><li><p>编译程序包</p><p>切换到catkin workspace 并查看src文件夹： </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> ~/catkin_ws/<br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span> src<br><span class="hljs-variable">$</span> catkin_make<br></code></pre></td></tr></table></figure><p>​       build目录是build space的默认所在位置，同时cmake和make也是在这里被调用来配置并编译程序包。</p></li></ul><p>​       devel目录是devel space的默认所在位置, 同时也是在安装程序包之前存放可执行文件和库文件的地方。</p><h3 id="5、理解ROS节点"><a href="#5、理解ROS节点" class="headerlink" title="5、理解ROS节点"></a>5、理解ROS节点</h3><ul><li>安装<code>ros-tutorials</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-builtin-name">get</span> install ros-kinetic-ros-tutorials<br></code></pre></td></tr></table></figure><ul><li><p>图概念</p><ul><li>Nodes:节点,一个节点即为一个可执行文件，它可以通过ROS与其它节点进行通信。</li><li>Messages:消息，消息是一种ROS数据类型，用于订阅或发布到一个话题。</li><li>Topics:话题,节点可以发布消息到话题，也可以订阅话题以接收消息。</li><li>Master:节点管理器，ROS名称服务 (比如帮助节点找到彼此)。</li><li>rosout: ROS中相当于stdout/stderr。</li><li>roscore: 主机+ rosout + 参数服务器</li></ul></li><li><p>客户端库</p><p>ROS客户端库允许使用不同编程语言编写的节点之间互相通信:</p><ul><li>rospy = python 客户端库</li><li>roscpp = c++ 客户端库</li><li>rosjs = javascripts客户端库</li><li>rosjava = java客户端库</li></ul></li><li><p>rescore</p><p>是运行所有ROS程序前首先要运行的命令 </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>roscore<br></code></pre></td></tr></table></figure></li><li><p>使用rosnode</p><p><code>rosnode list</code>指令列出活跃的节点</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosnode list<br></code></pre></td></tr></table></figure><p><code>rosnode info</code>命令返回的是关于一个特定节点的信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ rosnode <span class="hljs-builtin-name">info</span> /rosout<br></code></pre></td></tr></table></figure><p>另一个  <code>rosnode</code>  指令</p></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$ rosnode <span class="hljs-built_in">ping</span> my_turtle<br></code></pre></td></tr></table></figure><ul><li><p>使用<code> rosrun</code></p><p><code> rosrun</code>允许使用包名直接运行一个包内的节点 </p><p>打开一个新终端</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosrun turtlesim turtlesim_node<br></code></pre></td></tr></table></figure><p>再打开一个新终端</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosnode list<br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/rosout</span><br><span class="hljs-string">/turtlesim</span><br></code></pre></td></tr></table></figure><p> 关闭 <code>turtlesim </code>窗口停止运行节点 (或者回到<code>rosrun turtlesim</code>终端并使用<code>ctrl -C</code>) </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosrun turtlesim turtlesim_node <span class="hljs-symbol">__name:</span>=my_turtle<br></code></pre></td></tr></table></figure><p>这次</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/rosout</span><br><span class="hljs-string">/my_turtle</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200409_221407.jpg" alt="IMG_20200409_221407"></p><ul><li> 清除<code>rosnode </code>列表，通过: </li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosnode cleanup<br></code></pre></td></tr></table></figure><h3 id="6、理解ROS话题"><a href="#6、理解ROS话题" class="headerlink" title="6、理解ROS话题"></a>6、理解ROS话题</h3></li><li><p>通过键盘远程控制turtle</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>rqt_graph</code></p><p><code>rqt_graph</code>能够创建一个显示当前系统运行情况的动态图形。</p><ul><li>安装：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-builtin-name">get</span> install ros-kinetic-rqt<br>$ sudo apt-<span class="hljs-builtin-name">get</span> install ros-kinetic-rqt-common-plugins<br></code></pre></td></tr></table></figure><pre><code>*  在一个新终端中运行 </code></pre><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosrun rqt_graph rqt_graph<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200409_225612.jpg" alt="IMG_20200409_225612"></p><ul><li><code>rostopic</code>介绍</li></ul><p><code>rostopic</code>命令工具能让你获取有关ROS话题的信息。</p><ul><li><p>帮助选项</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rostopic -h<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用<code> rostopic echo</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic echo <span class="hljs-regexp">/turtle1/</span>cmd_vel<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>rostopic list</code></p><p><code>rostopic list</code>能够列出所有当前订阅和发布的话题。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rostopic list -h<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_204017.jpg" alt="IMG_20200410_204017"></p></li></ul><ul><li><p>在<code>rostopic list</code>中使用<code>verbose</code>选项：</p><p>会显示出有关所发布和订阅的话题及其类型的详细信息。 </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rostopic list -v<br></code></pre></td></tr></table></figure></li></ul><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_204350.jpg" alt="IMG_20200410_204350"></p><ul><li><p><code> ROS messages</code></p><ul><li><p>使用<code>rostopic type</code>可以查看发布在某个话题上的消息类型。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic type <span class="hljs-regexp">/turtle1/</span>cmd_vel<br></code></pre></td></tr></table></figure></li><li><p>使用<code>rosmsg</code>命令来查看消息的详细情况 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ rosmsg <span class="hljs-keyword">show</span> geometry_msgs/Twist<br></code></pre></td></tr></table></figure></li></ul></li><li><p>学习 <code>rostopic</code></p><ul><li><p>使用 <code>rostopic pub </code>可以把数据发布到当前某个正在广播的话题上</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic pub -<span class="hljs-number">1</span> <span class="hljs-regexp">/turtle1/</span>cmd_vel geometry_msgs/Twist -- <span class="hljs-string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="hljs-string">&#x27;[0.0, 0.0, 1.8]&#x27;</span><br></code></pre></td></tr></table></figure><p>以上命令会发送一条消息给<code>turtlesim</code>，告诉它以2.0大小的线速度和1.8大小的角速度开始移动。</p><p> 使用<code>rostopic pub -r</code>命令来发布一个稳定的命令流 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic pub <span class="hljs-regexp">/turtle1/</span>cmd_vel geometry_msgs/Twist -r <span class="hljs-number">1</span> -- <span class="hljs-string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="hljs-string">&#x27;[0.0, 0.0, 1.8]&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>rostopic hz</code> 可以用来查看数据发布的频率。 </p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic hz <span class="hljs-regexp">/turtle1/</span>pose<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_205748.jpg" alt="IMG_20200410_205748"></p><ul><li><p>结合rostopic type和rosmsg show命令来获取关于某个话题的更深层次的信息 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">rostopic <span class="hljs-keyword">type</span> <span class="hljs-type">/turtle1/cmd_vel </span>| rosmsg show<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 rqt_plot</p><ul><li> 使用rqt_plot命令来绘制正在发布到/turtle1/pose话题上的数据变化图形。 </li></ul></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosrun rqt_plot rqt_plot<br></code></pre></td></tr></table></figure><p>​         使用Ctrl-C退出rostopic命令 </p><h3 id="7、理解ROS服务和参数"><a href="#7、理解ROS服务和参数" class="headerlink" title="7、理解ROS服务和参数"></a>7、理解ROS服务和参数</h3><ul><li><p>ROS Services</p><ul><li>服务（services）是节点之间通讯的另一种方式。</li><li>服务允许节点发送请求（request） 并获得一个响应（response）</li></ul></li><li><p>使用rosservice</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rosservice list         输出可用服务的信息<br>rosservice call         调用带参数的服务<br>rosservice<span class="hljs-built_in"> type </span>        输出服务类型<br>rosservice <span class="hljs-builtin-name">find</span>         依据类型寻找服务<span class="hljs-builtin-name">find</span> services by<span class="hljs-built_in"> service </span>type<br>rosservice uri          输出服务的ROSRPC uri <br></code></pre></td></tr></table></figure><pre><code>* rosservice list</code></pre><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosservice list<br></code></pre></td></tr></table></figure><p>命令显示turtlesim节点提供了9个服务：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">重置（reset）<br>清除（<span class="hljs-keyword">clear</span>）<br>再生（spawn）<br>终止（kill）<br>turtle1/<span class="hljs-keyword">set</span>_pen<br><span class="hljs-string">/turtle1/teleport_absolute</span><br><span class="hljs-string">/turtle1/teleport_relative</span><br>turtlesim/get_loggers<br>turtlesim/<span class="hljs-keyword">set</span>_logger_level<br></code></pre></td></tr></table></figure><p>另外两个rosout节点提供的服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/rosout/g</span>et_loggers<br><span class="hljs-regexp">/rosout/</span>set_logger_level<br></code></pre></td></tr></table></figure><ul><li><p>rosservice type</p><ul><li><p>使用rosservice type命令更进一步查看clear服务:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> rosservice <span class="hljs-built_in">type</span> /<span class="hljs-built_in">clear</span><br></code></pre></td></tr></table></figure><p>​    得到<code>std_srvs/Empty</code></p></li></ul></li><li><p>rosservice call</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ rosservice <span class="hljs-keyword">call</span> <span class="hljs-keyword">clear</span><br></code></pre></td></tr></table></figure><p>​     服务清除了turtlesim_node的背景上的轨迹。 </p></li></ul></li></ul><p>  <img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_212120.jpg" alt="IMG_20200410_212120"></p><p>  ​     通过查看再生（spawn）服务的信息 </p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ rosservice <span class="hljs-keyword">type</span> <span class="hljs-type">spawn </span>| rossrv show<br></code></pre></td></tr></table></figure><p>  ​         可以在给定的位置和角度生成一只新的乌龟。 名字参数是可选的 </p>  <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$ rosservice <span class="hljs-built_in">call</span> spawn <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0.2</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>  ​            服务器返回名字：  <code>name: turtle2</code></p><ul><li><p>Using rosparam</p><p>rosparam使得我们能够存储并操作ROS参数服务器（Parameter Server）上的数据。</p><p>参数服务器能够存储整型、浮点、布尔、字符串、字典和列表等数据类型。</p><p>rosparam使用YAML标记语言的语法。</p><p> 操作参数 :</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">rosparam <span class="hljs-keyword">set</span>            设置参数<br>rosparam <span class="hljs-comment">get</span>            获取参数<br>rosparam <span class="hljs-comment">load</span>           从文件读取参数<br>rosparam <span class="hljs-comment">dump</span>           向文件中写入参数<br>rosparam <span class="hljs-comment">delete</span>         删除参数<br>rosparam <span class="hljs-comment">list</span>           列出参数名<br></code></pre></td></tr></table></figure><pre><code>* `rosparam list`</code></pre><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosparam list<br></code></pre></td></tr></table></figure><ul><li><code>rosparam set and rosparam get</code></li></ul></li></ul><p>  设定背景颜色 ,改变参数值使用rosparam set，获取参数值使用rosparam get </p>  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> rosparam <span class="hljs-keyword">set</span> background_r <span class="hljs-comment">150</span> <br></code></pre></td></tr></table></figure><p>   调用清除服务使得修改后的参数生效 </p>  <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ rosservice <span class="hljs-keyword">call</span> <span class="hljs-keyword">clear</span><br></code></pre></td></tr></table></figure><p>  查看参数服务器上的参数值——获取背景的绿色通道的值： </p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ rosparam <span class="hljs-builtin-name">get</span> background_g <br>86<br></code></pre></td></tr></table></figure><p>   使用rosparam get来显示参数服务器上的所有内容： </p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ rosparam <span class="hljs-builtin-name">get</span> /<br></code></pre></td></tr></table></figure><p>  <img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_212910.jpg" alt="IMG_20200410_212910"></p><ul><li><p><code>rosparam dump and rosparam load</code></p><p>存储这些信息以备今后重新读取</p><p>将所有的参数写入params.yaml文件： </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ rosparam dump <span class="hljs-keyword">params</span>.yaml<br></code></pre></td></tr></table></figure><p> 将yaml文件重载入新的命名空间，比如说copy空间: </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ rosparam <span class="hljs-built_in">load</span> params.yaml <span class="hljs-built_in">copy</span><br>$ rosparam <span class="hljs-built_in">get</span> <span class="hljs-built_in">copy</span>/background_b<br></code></pre></td></tr></table></figure><h3 id="8、使用rqt-console和roslaunch"><a href="#8、使用rqt-console和roslaunch" class="headerlink" title="8、使用rqt_console和roslaunch"></a>8、使用rqt_console和roslaunch</h3></li><li><p>rqt_console属于ROS日志框架(logging framework)的一部分，用来显示节点的输出信息</p></li><li><p>rqt_logger_level允许我们修改节点运行时输出信息的日志等级（logger levels）</p></li></ul><ul><li><p>日志等级按以下优先顺序排列：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Fatal<br>Error<br>Warn<br>Info<br>Debug<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>使用roslaunch</p><ul><li><p>roslaunch可以用来启动定义在launch文件中的多个节点</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>roscd beginner_tutorials<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ~/catkin_ws</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> devel/setup.bash</span><br><span class="hljs-meta">$</span><span class="bash"> roscd beginner_tutorials</span><br></code></pre></td></tr></table></figure><p>然后创建一个launch文件夹：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir launch<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> launch<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Launch 文件</p></li><li><p>Launch 文件解析</p></li><li><p>roslaunching</p><p>通过roslaunch命令来启动launch文件： </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ roslaunch beginner_tutorials turtlemimic.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><p>在一个新终端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic pub <span class="hljs-regexp">/turtlesim1/</span>turtle1<span class="hljs-regexp">/cmd_vel geometry_msgs/</span>Twist -r <span class="hljs-number">1</span> -- <span class="hljs-string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="hljs-string">&#x27;[0.0, 0.0, -1.8]&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_220234.jpg" alt="IMG_20200410_220234"></p><p>运行rqt并在主窗口中选择rqt_graph，或者直接：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rqt_graph<br></code></pre></td></tr></table></figure><h3 id="9、-使用rosed编辑ROS中的文件"><a href="#9、-使用rosed编辑ROS中的文件" class="headerlink" title="9、 使用rosed编辑ROS中的文件"></a>9、 使用rosed编辑ROS中的文件</h3></li><li><p>使用 rosed</p><p>rosed是rosbash 的一部分 ，直接通过package名来获取到待编辑的文件而无需指定该文件的存储路径</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">$ rosed roscpp <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Logger</span>.</span></span>msg<br></code></pre></td></tr></table></figure></li><li><p>使用Tab键补全文件名</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ rosed roscpp &lt;<span class="hljs-literal">tab</span>&gt;&lt;<span class="hljs-literal">tab</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>编辑器</p><p>rosed默认的编辑器是vim。如果想要将其他的编辑器设置成默认的，需要修改~/.bashrc 文件，增加如下语句: 如 将emacs设置成为默认编辑器 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">EDITOR</span>=<span class="hljs-string">&#x27;emacs -nw&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\Desktop\ros\IMG_20200410_223544.jpg" alt="IMG_20200410_223544"></p></li></ul><h3 id="10、创建ROS消息和ROS服务"><a href="#10、创建ROS消息和ROS服务" class="headerlink" title="10、创建ROS消息和ROS服务"></a>10、创建ROS消息和ROS服务</h3><ul><li><p>消息(msg)和服务(srv)介绍</p><ul><li>消息(msg): msg文件就是一个描述ROS中所使用消息类型的简单文本。它们会被用来生成不同语言的源代码。</li><li>服务(srv): 一个srv文件描述一项服务。它包含两个部分：请求和响应。</li><li>msg文件存放在package的msg目录下，srv文件则存放在srv目录下。</li><li>msg文件实际上就是每行声明一个数据类型和变量名。</li><li>在ROS中有一个特殊的数据类型：Header，它含有时间戳和坐标系信息。 </li></ul></li><li><p>使用 msg</p><ul><li><p>创建一个 msg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ~/catkin_ws/src/beginner_tutorials</span><br><span class="hljs-meta">$</span><span class="bash"> mkdir msg</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;int64 num&quot;</span> &gt; msg/Num.msg</span><br></code></pre></td></tr></table></figure></li><li><p>查看package.xml, 确保它包含一下两条语句:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>message_generation<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>message_runtime<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开CMakeLists.txt文件(可以参考前边的教程rosed)，并为下边这行代码去掉#: </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># rosbuild_genmsg()</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 rosmsg</p><p>通过rosmsg show命令，检查ROS是否能够识消息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ rosmsg <span class="hljs-keyword">show</span> beginner_tutorials/Num<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ rosmsg <span class="hljs-keyword">show</span> Num <br></code></pre></td></tr></table></figure></li><li><p>使用 srv</p><ul><li><p>创建一个srv</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>roscd beginner_tutorials<br><span class="hljs-variable">$ </span>mkdir srv<br></code></pre></td></tr></table></figure><p>​      roscp实现将文件从一个package复制到另外一个package的功能。</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">$ roscp rospy_tutorials <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AddTwoInts</span>.</span></span>srv srv/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AddTwoInts</span>.</span></span>srv<br></code></pre></td></tr></table></figure><p>​       删掉#，去除对下边语句的注释: </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># add_service_files(</span><br><span class="hljs-meta">#   FILES</span><br><span class="hljs-meta">#   Service1.srv</span><br><span class="hljs-meta">#   Service2.srv</span><br><span class="hljs-meta"># )</span><br></code></pre></td></tr></table></figure><p>​    用自己的srv文件名替换掉那些Service*.srv文件</p><ul><li><p>使用 rossrv</p><p>rossrv show命令，检查ROS是否能够识该服务。 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ rossrv <span class="hljs-keyword">show</span> beginner_tutorials/AddTwoInts<br></code></pre></td></tr></table></figure></li></ul></li><li><p>msg和srv都需要的步骤</p></li><li><p>获得帮助</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>rosmsg -h<br></code></pre></td></tr></table></figure></li><li><pre><code>rosmsg show 显示信息的描述rosmsg users  Find files that use messagerosmsg md5  显示信息的md5sumrosmsg package  列出信息所在的包rosmsg packages 列出包含信息的包<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">### 11、编写简单的消息发布器和订阅器 (C++)</span><br><br><span class="hljs-bullet">*</span> 编写发布器节点 <br><br>  <span class="hljs-code">`cd ~/catkin_ws/src/beginner_tutorials `</span><br><br><span class="hljs-bullet">  *</span> 源代码<br><br><span class="hljs-bullet">    -</span> 在beginner<span class="hljs-emphasis">_tutorials package路径下创建src目录:</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure>    mkdir -p ~/catkin_ws/src/beginner_tutorials/src    <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-operator">    *  </span>在beginner_tutorials package里创建src/talker.cpp文件,粘贴代码<br><br><span class="hljs-operator">  * </span>代码解释<br><br>    `#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span>`<br><br>    ros/ros.h是一个实用的头文件，它引用了ROS系统中大部分常用的头文件<br><br>    `  ros::init(argc, argv, <span class="hljs-string">&quot;talker&quot;</span>);`<br><br>     初始化ROS。它允许ROS通过命令行进行名称重映射 <br><br>    `ros::NodeHandle n;`<br><br><span class="hljs-operator">  * </span>总结：<br><br>    - 初始化ROS系统<br>    - 在ROS网络内广播将要在chatter topic上发布std_msgs/String消息<br>    - 以每秒<span class="hljs-number">10</span>次的频率在chatter上发布消息<br>    - 编写一个节点来接收消息。<br><br>* 编写订阅器节点 <br><br><span class="hljs-operator">  * </span>源代码<br><span class="hljs-operator">    *  </span>在beginner_tutorials package目录下创建src/listener.cpp文件，并粘贴 代码<br><span class="hljs-operator">  * </span>代码解释<br><span class="hljs-operator">  * </span>总结<br>    - 初始化ROS系统<br>    - 订阅chatter topic<br>    - 进入自循环，等待消息的到达<br>    - 当消息到达，调用chatter<span class="hljs-constructor">Callback()</span>函数<br><br>* 编译节点<br><br><span class="hljs-operator">  * </span>在<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CMakeLists</span>.</span></span>txt文件末尾加入几条语句:<br><br>  <span class="hljs-keyword">include</span><span class="hljs-constructor">_directories(<span class="hljs-params">include</span> $&#123;<span class="hljs-params">catkin_INCLUDE_DIRS</span>&#125;)</span><br><br>  add<span class="hljs-constructor">_executable(<span class="hljs-params">talker</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">talker</span>.<span class="hljs-params">cpp</span>)</span><br>  target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">talker</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br><br>  add<span class="hljs-constructor">_executable(<span class="hljs-params">listener</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">listener</span>.<span class="hljs-params">cpp</span>)</span><br>  target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">listener</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br><br><span class="hljs-operator">  * </span>运行 catkin_make: <br><br></code></pre></td></tr></table></figure>  $ catkin_make    <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br>### <span class="hljs-number">12</span>、写一个简单的消息发布器和订阅器 (Python)<br><br><br><br>### <span class="hljs-number">13</span>、测试消息发布器和订阅器<br><br>* 启动发布器<br><br></code></pre></td></tr></table></figure>$ roscore<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>$ cd ~/catkin_ws$ source ./devel/setup.bash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>$ rosrun beginner_tutorials talker      (C++)<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>启动订阅器<br><br></code></pre></td></tr></table></figure>$ rosrun beginner_tutorials listener     (C++)<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">14</span>、编写简单的服务器和客户端 (C++)<br><br>* 编写Service节点<br><br></code></pre></td></tr></table></figure>cd ~/catkin_ws/src/beginner_tutorials<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 代码<br><br>  在beginner<span class="hljs-emphasis">_tutorials包中创建src/add_</span>two<span class="hljs-emphasis">_ints_</span>server.cpp文件，并复制粘贴 代码<br><br><span class="hljs-bullet">-</span> 代码解释<br><br><span class="hljs-bullet">  -</span> beginner<span class="hljs-emphasis">_tutorials/AddTwoInts.h是由编译系统自动根据先前创建的srv文件生成的对应该srv文件的头文件。</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure>    bool add(beginner_tutorials::AddTwoInts::Request  &amp;req,             beginner_tutorials::AddTwoInts::Response &amp;res)    <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">    *</span> 这个函数提供两个int值求和的服务，int值从request里面获取，而返回数据装入response内，这些数据类型都定义在srv文件内部，函数返回一个boolean值。<br><br><span class="hljs-bullet">*</span> 编写Client节点<br><br><span class="hljs-bullet">  -</span> 代码<br><br><span class="hljs-code">    在beginner_tutorials包中创建src/add_two_ints_client.cpp文件，并复制粘贴 代码</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - 代码解释</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>  ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(&quot;add_two_ints&quot;);  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>    * 这段代码为add_two_ints service创建一个client。<br>    * ros::ServiceClient 对象待会用来调用service。<br><br>* 编译节点<br><br>  - 文件位于~<span class="hljs-regexp">/catkin_ws/</span>src<span class="hljs-regexp">/beginner_tutorials/</span>CMakeLists.txt，并将下面的代码添加在文件末尾：<br><br></code></pre></td></tr></table></figure>  add_executable(add_two_ints_server src/add_two_ints_server.cpp)  target_link_libraries(add_two_ints_server $&#123;catkin_LIBRARIES&#125;)  add_dependencies(add_two_ints_server beginner_tutorials_gencpp)  add_executable(add_two_ints_client src/add_two_ints_client.cpp)  target_link_libraries(add_two_ints_client $&#123;catkin_LIBRARIES&#125;)  add_dependencies(add_two_ints_client beginner_tutorials_gencpp)  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>运行catkin_make命令： <br><br></code></pre></td></tr></table></figure>  cd ~/catkin_ws  catkin_make  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>运行节点<br><br></code></pre></td></tr></table></figure>roscore<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>运行service<br><br></code></pre></td></tr></table></figure>  rosrun beginner_tutorials add_two_ints_server  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>运行client<br><br></code></pre></td></tr></table></figure>  $ rosrun beginner_tutorials add_two_ints_client 1 3  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">15</span>、编写简单的Service和Client (Python)<br><br><br><br>### <span class="hljs-number">16</span>、测试简单的Service和Client<br><br>* 运行Service<br><br></code></pre></td></tr></table></figure>$ rosrun beginner_tutorials add_two_ints_server     (C++)<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>* 运行<span class="hljs-built_in">Client</span><br><br></code></pre></td></tr></table></figure>$ rosrun beginner_tutorials add_two_ints_client 1 3     (C++)<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">17</span>、录制与回放数据<br><br>* 录制数据（通过创建一个bag文件）<br><br>  在三个终端执行<br><br></code></pre></td></tr></table></figure>roscorerosrun turtlesim turtlesim_node rosrun turtlesim turtle_teleop_key<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>录制所有发布的话题<br><br><span class="hljs-code">  打开一个新终端并执行： </span><br><br></code></pre></td></tr></table></figure>  rostopic list -v  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>打开一个新的终端窗口，在终端中执行以下命令： <br><br></code></pre></td></tr></table></figure>  mkdir ~/bagfiles  cd ~/bagfiles  rosbag record -a  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> 检查并回放bag文件<br><br>  使用rosbag play命令回放出来<br><br><span class="hljs-bullet">  -</span> 在bag文件所在的目录下执行以下命令：<br><br></code></pre></td></tr></table></figure>  rosbag info &lt;your bagfile&gt;  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>在终端中bag文件所在目录下运行以下命令： <br><br></code></pre></td></tr></table></figure>  rosbag play &lt;your bagfile&gt;  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>以两倍的速度通过按键发布控制命令时产生的轨迹<br><br></code></pre></td></tr></table></figure>  rosbag play -r 2 &lt;your bagfile&gt;  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>* 录制数据子集<br><br>  * 重新启动（relaunch）键盘控制节点相关的启动文件（<span class="hljs-built_in">launch</span> <span class="hljs-built_in">file</span>)： <br><br></code></pre></td></tr></table></figure>  rosrun turtlesim turtlesim_node   rosrun turtlesim turtle_teleop_key  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>在bag文件所在目录下执行以下命令：<br><br></code></pre></td></tr></table></figure>  rosbag record -O subset /turtle1/command_velocity /turtle1/pose  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>* rosbag record/play 命令的局限性<br><br>  turtle的路径可能并没有完全地映射到原先通过键盘控制时产生的路径上——整体形状应该是差不多的，但没有完全一样。 <br><br>### <span class="hljs-number">18</span>、roswtf入门<br><br>通过如下，判断`roscore`是否在执行，如下是在运行：<br><br></code></pre></td></tr></table></figure>$ ps -ef | grep -i rosmaster00:00:00 /usr/bin/python /opt/ros/kinetic/bin/rosmaster <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> 安装检查<br><span class="hljs-bullet">  *</span>  roswtf 可以检查你的ROS系统并尝试发现问题 <br><br></code></pre></td></tr></table></figure>$ roscd rosmaster$ roswtf<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>运行时检查（在有ROS节点运行时）<br><br><span class="hljs-code">  先在一个终端运行roscore，之后</span><br><br></code></pre></td></tr></table></figure>$ roscd$ roswtf<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">*</span> 错误报告<br><br><span class="hljs-bullet">  -</span> roswtf会对一些系统中看起来异常但可能是正常的运行情况发出警告。也会对确实有问题的情况报告错误。<br><br>   在ROS<span class="hljs-emphasis">_PACKAGE_</span>PATH 环境变量中设置一个 bad值，并退出roscore以简化检查输出信息<br><br></code></pre></td></tr></table></figure>$ roscd$ ROS_PACKAGE_PATH=bad:$ROS_PACKAGE_PATH roswtf</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL</title>
    <link href="/2020/04/04/00008-STL/"/>
    <url>/2020/04/04/00008-STL/</url>
    
    <content type="html"><![CDATA[<h1 id="STL学习报告"><a href="#STL学习报告" class="headerlink" title="STL学习报告"></a>STL学习报告</h1><p>[TOC]</p><h2 id="一、STL"><a href="#一、STL" class="headerlink" title="一、STL"></a>一、STL</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>标准模板库   Standard Template Library</p><p>分为：容器container、算法algorithm、迭代器iterator</p><h3 id="2-六大组件"><a href="#2-六大组件" class="headerlink" title="2.六大组件"></a>2.六大组件</h3><h5 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（<em>Container）</em></h5><p>​       将数据结构实现，如数组，链表，树，栈，队列，集合，映射表</p><p>​            序列式容器：<br>​            关联式容器：</p><h5 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（<em>Algorithm）</em></h5><p>​        质变算法：<br>​        非质变算法：</p><h5 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（<em>Iterator）</em></h5><p>​    每个容器都有自己的专属迭代器</p><p>​         输入迭代器：<br>​         输出迭代器：<br>​         前向迭代器：<br>​         双向迭代器：<br>​         随机访问迭代器：</p><h5 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h5><h5 id="适配器（配接器）"><a href="#适配器（配接器）" class="headerlink" title="适配器（配接器）"></a>适配器（配接器）</h5><h5 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h5><h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h2><p>学习STL中常用的容器，如vector，queue，stack，set，map等，并总结其用法，功能</p><h3 id="1-vector-向量"><a href="#1-vector-向量" class="headerlink" title="1.vector  向量"></a>1.vector  向量</h3><p>向量（Vector）</p><p>​        是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><p>​         单端数组<br>​         动态扩展：找更大空间，拷贝数据，释放原空间<br>​         vector容器的迭代器是支持随机访问的迭代器</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-built_in">vector</span>&lt;T&gt;v;<span class="hljs-comment">//创建一个空vector</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-keyword">int</span> nSize);<span class="hljs-comment">//创建一个vector,元素个数为nSize</span><br><span class="hljs-built_in">vector</span>(v.begin(),v.end());<span class="hljs-comment">//复制[v.begin(),v.end())区间内另一个数组的元素到vector中</span><br><span class="hljs-built_in">vector</span>(n,elem);<span class="hljs-comment">//构造函数将n个elem拷贝给本身</span><br><span class="hljs-built_in">vector</span>（<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span> &amp;vec);<span class="hljs-comment">//复制构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-keyword">int</span> nSize,<span class="hljs-keyword">const</span> t&amp; t);<span class="hljs-comment">//创建一个vector，元素个数为nSize,且值均为t</span><br></code></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-built_in">vector</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span> &amp;vec);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">const</span> T&amp; x)</span></span>;<span class="hljs-comment">//设置向量中第n个元素的值为x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(const_iterator first,const_iterator last)</span></span>;<span class="hljs-comment">//向量中[first,last)中元素设置成当前向量元素</span><br></code></pre></td></tr></table></figure><h4 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br>empty();<span class="hljs-comment">//判断是否为空</span><br>capacity();<span class="hljs-comment">//容量</span><br>size();<span class="hljs-comment">//返回容器中元素个数，返回类型是size_type类型</span><br>resize(<span class="hljs-keyword">int</span> num);<span class="hljs-comment">//重新指定长度为num，若容器变长，则以默认值填充新位置，</span><br>                <span class="hljs-comment">//若容器变短，超出长度的元素被删除</span><br>resize(<span class="hljs-keyword">int</span> num,elem);<span class="hljs-comment">//重新指定长度为num，若容器变长，则以elem填充新位置，</span><br>                     <span class="hljs-comment">//若容器变短，超出长度的元素被删除</span><br><br></code></pre></td></tr></table></figure><h4 id="插入函数"><a href="#插入函数" class="headerlink" title="插入函数"></a>插入函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br>push_back(elem);<span class="hljs-comment">//尾插元素elem</span><br>insert(const_iterator pos,ele);<span class="hljs-comment">//pos处插入elem</span><br>insert(const_iterator pos,<span class="hljs-keyword">int</span> n, elem);<span class="hljs-comment">//pos处插入n个elem</span><br>iterator insert(iterator it,const_iterator first,const_iterator last)；//向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据<br></code></pre></td></tr></table></figure><h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br>pop_back();<span class="hljs-comment">//删除最后一个元素</span><br>erase(const_itrator pos);<span class="hljs-comment">//删除指向元素</span><br>erase(const_itrator start ,const_itrator end);<span class="hljs-comment">//删除从start到end</span><br>clear();<span class="hljs-comment">//删除所有</span><br></code></pre></td></tr></table></figure><h4 id="遍历函数"><a href="#遍历函数" class="headerlink" title="遍历函数"></a>遍历函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-function">reference <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span>:<span class="hljs-comment">//返回pos位置元素的引用</span></span><br><span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span>:<span class="hljs-comment">//返回首元素的引用</span></span><br><span class="hljs-function">reference <span class="hljs-title">back</span><span class="hljs-params">()</span>:<span class="hljs-comment">//返回尾元素的引用</span></span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span>:<span class="hljs-comment">//返回向量头指针，指向第一个元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span>:<span class="hljs-comment">//返回向量尾指针，指向向量最后一个元素的下一个位置</span></span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span><span class="hljs-params">()</span>:<span class="hljs-comment">//反向迭代器，指向最后一个元素</span></span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span><span class="hljs-params">()</span>:<span class="hljs-comment">//反向迭代器，指向第一个元素之前的位置</span></span><br></code></pre></td></tr></table></figure><h4 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br>bool empty() const；//判断向量是否为空，若为空，则向量中无元素<br></code></pre></td></tr></table></figure><h4 id="大小函数"><a href="#大小函数" class="headerlink" title="大小函数"></a>大小函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">原型：<br>int size() const；//返回向量中元素的个数<br>int capacity() const；//返回当前向量所能容纳的最大元素值<br>int max_size() const；//返回最大可允许的vector元素数量值<br></code></pre></td></tr></table></figure><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">原型：<br>at(<span class="hljs-keyword">int</span> idx);<span class="hljs-comment">//返回idx所指元素</span><br>operate[];<span class="hljs-comment">//返回idx所指元素</span><br>front();<span class="hljs-comment">//返回第一个元素</span><br>back（);<span class="hljs-comment">//返回最后一个元素</span><br></code></pre></td></tr></table></figure><h4 id="容器互换"><a href="#容器互换" class="headerlink" title="容器互换"></a>容器互换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br>swap（vec);<span class="hljs-comment">//将vec与本身元素互换</span><br></code></pre></td></tr></table></figure><h4 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h4><p>减少vector在动态扩展容量时的扩展次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">原型:<br>reserve(<span class="hljs-keyword">int</span> len);<span class="hljs-comment">//容器预留len个元素长度，预留位置不初始化，元素不可以访问</span><br></code></pre></td></tr></table></figure><h3 id="2-queue队列"><a href="#2-queue队列" class="headerlink" title="2.queue队列"></a>2.queue队列</h3><p>​    队列(queue) </p><p>​            只能访问queue容器适配器的第一个和最后一个元素，不允许随机访问队列元素，不允许遍历队列。只能在容器的末尾添加新元素，只能从头部移除元素。</p><p>​            FIFO（先进先出） </p><p>​            不允许遍历</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">queue</span>&lt;T&gt; que;<br><span class="hljs-built_in">queue</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">queue</span> &amp;que);<br></code></pre></td></tr></table></figure><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span>&amp; <span class="hljs-keyword">operator</span>=（<span class="hljs-keyword">const</span> <span class="hljs-built_in">queue</span> &amp;que）；<br><br></code></pre></td></tr></table></figure><h4 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">push（elem）；<span class="hljs-comment">//向队尾添加元素</span><br>pop（）；<span class="hljs-comment">//从队头移除第一个元素，注意，并不会返回被弹出元素的值</span><br>back();<span class="hljs-comment">//返回最后一个元素</span><br>front();<span class="hljs-comment">//返回第一个元素</span><br><br></code></pre></td></tr></table></figure><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">empty（);<span class="hljs-comment">//如果队列空则返回真</span><br>size();<span class="hljs-comment">//返回队列中元素的个数</span><br></code></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p>​            ！ 队列中没有clear（）操作    </p><p>​            清空方法：</p><p>​                 第一种：直接用空的队列对象赋值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q1<br>q1=<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br></code></pre></td></tr></table></figure><p>​                 第二种：遍历出队列 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!q.empty())q.pop();<br></code></pre></td></tr></table></figure><p>​                 第三种：使用swap，这种是最高效的，定义clear，保持STL容器的标准 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;empty;<br>    swap(empty,q);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-stack堆栈"><a href="#3-stack堆栈" class="headerlink" title="3.stack堆栈"></a>3.stack堆栈</h3><p>​    堆栈 stack</p><p>​         堆栈是一个线性表，插入和删除只在表的一端进行。 </p><p>​        不允许随机访问栈元素，不允许遍历栈，把使用限制在定义栈的基本操作上</p><p>​         后进先出（  LIFO） </p><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stack</span>&lt;T&gt; stk;<br><span class="hljs-built_in">stack</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">stack</span> &amp;stk);<br></code></pre></td></tr></table></figure><h4 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stack</span>&amp; <span class="hljs-keyword">operator</span>=（<span class="hljs-keyword">const</span> <span class="hljs-built_in">stack</span> &amp;stk）；<br></code></pre></td></tr></table></figure><h4 id="存取-1"><a href="#存取-1" class="headerlink" title="存取"></a>存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">push（elem）；<span class="hljs-comment">//向栈顶添加元素</span><br>  pop（）；<span class="hljs-comment">//从栈顶移除第一个元素，注意这个函数无返回值，如果需要获取栈顶元素，应先调用top()，再pop()</span><br>  top（）;<span class="hljs-comment">//返回栈顶元素</span><br></code></pre></td></tr></table></figure><h4 id="大小-1"><a href="#大小-1" class="headerlink" title="大小"></a>大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">empty（）;<span class="hljs-comment">//测试栈是否为空，为空返回true，否则返回false</span><br>size();<span class="hljs-comment">//返回栈中元素的个数</span><br></code></pre></td></tr></table></figure><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">void swap(stack&amp; x)；//　重载1：x.swap(y)<br><br>void swap(stack&amp; x, stack&amp; y)；//重载2: swap(x, y)<br></code></pre></td></tr></table></figure><h3 id="4-set集合"><a href="#4-set集合" class="headerlink" title="4.set集合"></a>4.set集合</h3><p>​    集合 set</p><p>​        set     multiset</p><p>​        所有元素插入后自动排序<br>​        属于关联式容器，底层结构是用二叉树实现<br>​        set不允许有重复数据，multiset允许有重复数据</p><h4 id="构造和赋值"><a href="#构造和赋值" class="headerlink" title="构造和赋值"></a>构造和赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">set</span>&lt;T&gt; st;<br><span class="hljs-built_in">set</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">set</span> &amp;st);<br><span class="hljs-built_in">set</span> &amp;<span class="hljs-keyword">operator</span> =(<span class="hljs-keyword">const</span> <span class="hljs-built_in">set</span> &amp;st);<br><br></code></pre></td></tr></table></figure><h4 id="大小和交换"><a href="#大小和交换" class="headerlink" title="大小和交换"></a>大小和交换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">size();<span class="hljs-comment">//返回当前set容器中的元素个数</span><br>empty();<span class="hljs-comment">//判断set容器是否为空</span><br>swap();<span class="hljs-comment">//交换两个集合容器</span><br><br></code></pre></td></tr></table></figure><h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">insert(elem);<span class="hljs-comment">//插入一个元素</span><br>clear();<span class="hljs-comment">//删除set容器中的所有的元素</span><br>erase(pos);<span class="hljs-comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br>erase(beg,end);<span class="hljs-comment">//删除区间[)所有的元素，返回下一个元素的迭代器</span><br>erase(elem）；<br><br></code></pre></td></tr></table></figure><h4 id="查找和统计"><a href="#查找和统计" class="headerlink" title="查找和统计"></a>查找和统计</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">      s.begin()；<span class="hljs-comment">//返回set容器的第一个元素</span><br>s.end()；<span class="hljs-comment">//返回set容器的最后一个元素</span><br>      find（key）；<span class="hljs-comment">//查找key是否存在，若存在，返回该元素迭代器//位置，否则，返回set.end()</span><br>      count(key);<span class="hljs-comment">//统计key个数</span><br>  <span class="hljs-built_in">pair</span>队组创建：<br>      pair&lt;type,type&gt; p (value1, value2);<br>      <span class="hljs-built_in">pair</span>&lt;type,type&gt; p=<span class="hljs-built_in">make_pair</span>(value1,value2);<br>  <span class="hljs-built_in">set</span>容器排序<br>      利用仿函数，改变排序规则<br></code></pre></td></tr></table></figure><h3 id="5-map映射"><a href="#5-map映射" class="headerlink" title="5.map映射"></a>5.map映射</h3><p>​    映射 map</p><p>​            map  multimap</p><p>​            元素都是pair<br>​            key—–value， 键值与映照数据之间具有一一映照<br>​            所有元素会根据元素的键值自动排序<br>​            map不允许有重复的key值，multimap可以</p><h4 id="构造和赋值-1"><a href="#构造和赋值-1" class="headerlink" title="构造和赋值"></a>构造和赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>&lt;T1,T2&gt; mp;<br><span class="hljs-built_in">map</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">map</span> &amp;p);<br><span class="hljs-built_in">map</span>&amp; oprator=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">map</span> &amp;mp);<br></code></pre></td></tr></table></figure><h4 id="大小和交换-1"><a href="#大小和交换-1" class="headerlink" title="大小和交换"></a>大小和交换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">size（）；<span class="hljs-comment">//返回 map 中元素的个数</span><br>empty();<span class="hljs-comment">//如果 map 为空则返回 true</span><br>swap(st);<span class="hljs-comment">//交换两个 map</span><br></code></pre></td></tr></table></figure><h4 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">insert(elem);<br>clear();<br>erase(pos);<br>erase(beg,end);<br>erase(key);<br><br></code></pre></td></tr></table></figure><h4 id="查找和统计-1"><a href="#查找和统计-1" class="headerlink" title="查找和统计"></a>查找和统计</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"> begin() ；<span class="hljs-comment">//返回指向 map 头部的迭代器     </span><br>end() ；<span class="hljs-comment">//返回指向 map 末尾的迭代器</span><br>rbegin() 返回一个指向 <span class="hljs-built_in">map</span> c++<br>rend() 返回一个指向 <span class="hljs-built_in">map</span> 头部的逆向迭代器<br>      find（key）；<span class="hljs-comment">// 查找一个元素</span><br>      count（key）；<span class="hljs-comment">//返回指定元素出现的次数</span><br>      upper_bound() 返回键值&gt;给定元素的第一个位置<br>      lower_bound() 返回键值&gt;=给定元素的第一个位置<br></code></pre></td></tr></table></figure><h3 id="6-list表"><a href="#6-list表" class="headerlink" title="6.list表"></a>6.list表</h3><p>​    表 list</p><p>​            STL中的链表是双向循环链表<br>            链表的迭代器是双向迭代器</p><p>​             List则是一段不连续的内存空间 </p><p>​            缺点：遍历速度没数组快，占用空间比数组大</p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; c0; <span class="hljs-comment">//空链表</span><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//建一个含三个默认值是0的元素的链表</span><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//建一个含五个元素的链表，值都是2</span><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c4</span><span class="hljs-params">(c2)</span></span>; <span class="hljs-comment">//建一个c2的copy链表</span><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c5</span><span class="hljs-params">(c1.begin(),c1.end())</span></span>; <span class="hljs-comment">//c5含c1一个区域的元素[_First, _Last)</span><br><br></code></pre></td></tr></table></figure><h4 id="赋值和交换"><a href="#赋值和交换" class="headerlink" title="赋值和交换"></a>赋值和交换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">assign(beg,end);<span class="hljs-comment">//将[beg,end)区间的元素拷贝赋值给链表c。</span><br>assign(n,elem);<span class="hljs-comment">//将n个elem拷贝赋值给链表c。</span><br><span class="hljs-built_in">list</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; L);<br>c1.swap(c2); <span class="hljs-comment">//将c1和c2交换</span><br>swap(c1,c2);<span class="hljs-comment">//将c1和c2交换</span><br></code></pre></td></tr></table></figure><h4 id="大小-2"><a href="#大小-2" class="headerlink" title="大小"></a>大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">size（）；<span class="hljs-comment">//返回链表c中实际元素的个数</span><br>empty();<span class="hljs-comment">//判断是否为空</span><br>resize(num);<span class="hljs-comment">//从新定义链表的长度,超出原始长度部分用0代替,小于原始部分删除</span><br>resize(num,elem);<span class="hljs-comment">// 从新定义链表的长度,超出原始长度部分用elem代替</span><br></code></pre></td></tr></table></figure><h4 id="合并连接"><a href="#合并连接" class="headerlink" title="合并连接"></a>合并连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">c1.merge(c2)；<span class="hljs-comment">//合并2个有序的链表并使之有序,从新放到c1里,释放c2</span><br>c1.merge(c2,comp)；<span class="hljs-comment">//合并2个有序的链表并使之按照自定义规则排序之后从新放到c1中,释放c2</span><br>c1.splice(c1.beg,c2)；<span class="hljs-comment">//将c2连接在c1的beg位置,释放c2</span><br>c1.splice(c1.beg,c2,c2.beg)；<span class="hljs-comment">//将c2的beg位置的元素连接到c1的beg位置，并且在c2中施放掉beg位置的元素</span><br>c1.splice(c1.beg,c2,c2.beg,c2.end)；<span class="hljs-comment">//将c2的[beg,end)位置的元素连接到c1的beg位置并且释放c2的[beg,end)位置的元素</span><br></code></pre></td></tr></table></figure><h4 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">push_back(elem);<span class="hljs-comment">//在末尾增加一个元素</span><br>pop_back();<span class="hljs-comment">//删除末尾的元素</span><br>push_front(elem);<span class="hljs-comment">//在开始位置增加一个元素</span><br>pop_front();<span class="hljs-comment">//删除第一个元素</span><br>insert(pos,elem);<span class="hljs-comment">//在pos位置插入元素elem</span><br>insert(pos,n,elem);<span class="hljs-comment">//在pos位置插入n个元素elem</span><br>insert(pos,beg,end);<span class="hljs-comment">//在pos位置插入区间为[beg,end)的元素</span><br>clear();<br>erase(beg,end);<span class="hljs-comment">//删除[），返回下一个数据的位置</span><br>erase(pos);<span class="hljs-comment">//删除pos位置的元素</span><br>remove(elem);<br></code></pre></td></tr></table></figure><h4 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">front();<span class="hljs-comment">//返回第一元素</span><br>back(）；<span class="hljs-comment">//返回最后一个元素</span><br><br></code></pre></td></tr></table></figure><h4 id="反转和排序"><a href="#反转和排序" class="headerlink" title="反转和排序"></a>反转和排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">reserve();<span class="hljs-comment">//反转链表</span><br>sort();<span class="hljs-comment">//链表排序</span><br></code></pre></td></tr></table></figure><h3 id="7-deque双端队列"><a href="#7-deque双端队列" class="headerlink" title="7.deque双端队列"></a>7.deque双端队列</h3><p>​    双端队列 deque</p><p>​            双端数组<br>​            内部有一个中控器</p><pre><code>      deque双向开口可进可出的容器 ， 是一种双向开口的连续线性空间 </code></pre><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">deque</span>&lt;T&gt; deq; <span class="hljs-comment">//默认构造形式</span><br><span class="hljs-built_in">deque</span>(beg,end); <span class="hljs-comment">//构造函数将[beg, end)区间中的元素拷贝给本身</span><br><span class="hljs-built_in">deque</span>(n,elem); <span class="hljs-comment">//构造函数将 n 个 elem 拷贝给本身</span><br><span class="hljs-built_in">deque</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">deque</span> &amp;deq); <span class="hljs-comment">//拷贝构造函数</span><br></code></pre></td></tr></table></figure><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">assign(beg,end); <span class="hljs-comment">//将[beg, end)区间中的数据拷贝赋值给本身</span><br>assign(n,elem); <span class="hljs-comment">//将 n 个 elem 拷贝赋值给本身</span><br><span class="hljs-built_in">deque</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">deque</span> &amp;deq); <span class="hljs-comment">//重载等号操作符</span><br>swap(deq); <span class="hljs-comment">//将 deq 与本身的元素互换</span><br></code></pre></td></tr></table></figure><h4 id="大小-3"><a href="#大小-3" class="headerlink" title="大小"></a>大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">deque</span>.size(); <span class="hljs-comment">//返回容器中元素的个数</span><br><span class="hljs-built_in">deque</span>.empty(); <span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-built_in">deque</span>.resize(num);<span class="hljs-comment">//重新指定容器的长度为 num,若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-built_in">deque</span>.resize(num, elem); <span class="hljs-comment">//重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除</span><br></code></pre></td></tr></table></figure><h4 id="存取数据"><a href="#存取数据" class="headerlink" title="存取数据"></a>存取数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">at(idx);<span class="hljs-comment">//返回索引 idx 所指的数据，如果 idx 越界，抛出 out_of_range</span><br><span class="hljs-keyword">operator</span>[];<span class="hljs-comment">//返回索引 idx 所指的数据，如果 idx 越界，不抛出异常，直接出错</span><br>front();<span class="hljs-comment">//返回第一个数据</span><br>back();<span class="hljs-comment">//返回最后一个数据</span><br></code></pre></td></tr></table></figure><h4 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h4><h5 id="两端操作"><a href="#两端操作" class="headerlink" title="两端操作"></a>两端操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">push_back(elem);<span class="hljs-comment">//在容器尾部添加一个数据</span><br>push_front(elem);<span class="hljs-comment">//在容器头部插入一个数据</span><br>pop_back();<span class="hljs-comment">//删除容器最后一个数据</span><br>pop_front();<span class="hljs-comment">//删除容器第一个数据</span><br></code></pre></td></tr></table></figure><h5 id="指定位置操作"><a href="#指定位置操作" class="headerlink" title="指定位置操作"></a>指定位置操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">insert(pos,elem);<span class="hljs-comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置</span><br>insert(pos,n,elem);<span class="hljs-comment">//在pos位置插入一个elem元素的拷贝，无返回值</span><br>insert(pos,beg,end);<span class="hljs-comment">//在pos位置插入一个[beg，end）区间的数据，无返回值</span><br>clear();<span class="hljs-comment">//</span><br>erase(beg,end);<span class="hljs-comment">//删除[beg，end）区间的数据，返回下一个数据的位置</span><br>erase(pos);<span class="hljs-comment">//删除pos位置的数据，返回下一个元素的位置</span><br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">sort(iterator beg,iterator end)<span class="hljs-comment">//对deg和end区间内的元素进行排序</span><br><span class="hljs-built_in">vector</span>也可以<br></code></pre></td></tr></table></figure><h2 id="三、string"><a href="#三、string" class="headerlink" title="三、string"></a>三、string</h2><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-built_in">string</span>();<span class="hljs-comment">//创建一个空的字符串 </span><br><span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s)<span class="hljs-comment">//使用字符串s初始化</span><br><span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str)<span class="hljs-comment">//使用一个string对象初始化另一个string对象</span><br><span class="hljs-built_in">string</span>(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span> c)<span class="hljs-comment">//使用n个字符c初始化</span><br></code></pre></td></tr></table></figure><h5 id="2-赋值操作"><a href="#2-赋值操作" class="headerlink" title="2.赋值操作"></a>2.赋值操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s);<span class="hljs-comment">//</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s);<span class="hljs-comment">//</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">char</span> c);<span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-comment">//将字符串的 前n个赋给当前字符串</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> c)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="3-字符串拼接"><a href="#3-字符串拼接" class="headerlink" title="3.字符串拼接"></a>3.字符串拼接</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s);<span class="hljs-comment">//</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c);<span class="hljs-comment">//</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s);<span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-comment">//将字符串s的 前n个连接到当前字符串结尾</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s ，<span class="hljs-keyword">int</span> pos，<span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-comment">//将字符串s从pos开始的n个连接到当前字符串结尾</span><br><br></code></pre></td></tr></table></figure><h5 id="4-字符串查找与替换"><a href="#4-字符串查找与替换" class="headerlink" title="4.字符串查找与替换"></a>4.字符串查找与替换</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">原型：<br><span class="hljs-comment">//find从左往右查</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str,<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//查找str第一次出现位置，从pos开始查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s,<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//查找s第一次出现位置，从pos开始查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s,<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> n)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//从pos开始查找s前n个字符第一次出现位置</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c,<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//查找字符c第一次出现位置</span><br><span class="hljs-comment">//rfind从右往左查</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str,<span class="hljs-keyword">int</span> pos=npos)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//查找str最后一个位置，从pos开始查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s,<span class="hljs-keyword">int</span> pos=npos)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//查找s最后一个位置，从pos开始查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s,<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> n)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//从pos开始查找s前n个字符最后一次出现位置</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c,<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//查找字符c第一次出现位置</span><br><br><span class="hljs-function">size_type <span class="hljs-title">find_first_not_of</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;str,size_type index =<span class="hljs-number">0</span> )</span><span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//返回在字符串中首次出现的不匹配str中的任何一个字符的首字符索引, 从index开始搜索, 如果全部匹配则返回string::npos</span><br><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> n,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;str)</span></span>;<span class="hljs-comment">//替换从pos开始 n个字符为字符串str</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos，<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s)</span></span>;<span class="hljs-comment">//替换从pos开始 n个字符为字符串s</span><br><br></code></pre></td></tr></table></figure><h5 id="5-字符串比较"><a href="#5-字符串比较" class="headerlink" title="5.字符串比较"></a>5.字符串比较</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">：按字符的ASCII码<br>&gt;返回<span class="hljs-number">1</span><br>&lt;返回<span class="hljs-number">-1</span><br>=返回<span class="hljs-number">0</span><br>原型：<br><span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)<span class="hljs-keyword">const</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span><span class="hljs-keyword">const</span></span>;<br><br></code></pre></td></tr></table></figure><h5 id="6-字符存取"><a href="#6-字符存取" class="headerlink" title="6.字符存取"></a>6.字符存取</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">：单个字符存取<br>原型：<br><span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> n);<br><span class="hljs-function"><span class="hljs-keyword">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="7-string插入与删除"><a href="#7-string插入与删除" class="headerlink" title="7.string插入与删除"></a>7.string插入与删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">：对字符<br>原型：<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> c)</span></span>;<span class="hljs-comment">//在指定位置插入n个字符</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> n=npos)</span></span>;<span class="hljs-comment">//删除从pos开始的n个字符</span><br></code></pre></td></tr></table></figure><h5 id="8-子串"><a href="#8-子串" class="headerlink" title="8.子串"></a>8.子串</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">：获取想要的子串<br>原型：<br><span class="hljs-built_in">string</span> substr（<span class="hljs-keyword">int</span> pos =<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> n=npos)<span class="hljs-keyword">const</span>;<span class="hljs-comment">//返回由pos开始的n个字符串</span><br></code></pre></td></tr></table></figure><h2 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;  //是STL头文件中最大的一个，范围涉及到比较，交换，查找，遍历操作，赋值，修改等等</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;numeric&gt;    //体积很小，只包括几个在序列上面进行简单数学运算的模板函数</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; //定义了一些常用的模板类，用以声明函数对象</span></span><br><br></code></pre></td></tr></table></figure><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><h4 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1.遍历"></a>1.遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">遍历；<br>for_each    <span class="hljs-comment">//遍历容器</span><br>transform   <span class="hljs-comment">//搬运容器到另一个容器</span><br>transform(iterator beg1,iterator，end1,iterator beg2,_func);<br><span class="hljs-comment">//beg1;原容器开始迭代器</span><br><span class="hljs-comment">//end1:原容器结束迭代器</span><br><span class="hljs-comment">//beg2:目标容器开始迭代器</span><br><span class="hljs-comment">//func:函数或者函数对象</span><br></code></pre></td></tr></table></figure><h4 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">查找：<br>find<br>find （iterator beg ,iterator end,value)<br><br>find_if          <span class="hljs-comment">//按条件查找</span><br>find_if （iterator beg ,iterator end,_pred)<br><span class="hljs-comment">//_pred 函数或者谓词（返回bool类型的仿函数）</span><br><br>adjacent_find  <span class="hljs-comment">//查找相邻重复元素</span><br>adjacent_find （iterator beg ,iterator end )<br><span class="hljs-comment">//返回相邻元素的第一个位置的迭代器</span><br><br>binary_search   <span class="hljs-comment">//二分查找</span><br><span class="hljs-keyword">bool</span> binary_search（iterator beg ,iterator end,value)<br><span class="hljs-comment">//在无序序列中不可以用</span><br><br>count  <span class="hljs-comment">//统计元素出现次数</span><br>count（iterator beg ,iterator end,value)<br><br>count_if    <span class="hljs-comment">//按条件统计元素个数</span><br>count_if（iterator beg ,iterator end,_pred)<br></code></pre></td></tr></table></figure><h4 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">排序：<br>sort<span class="hljs-comment">//</span><br>sort（iterator beg ,iterator end,_pred)<br><br>random_shuffle<span class="hljs-comment">//洗牌 指定位置内的元素随机调整次序</span><br>random_shuffle（iterator beg ,iterator end）<br><span class="hljs-comment">//注意：时间种子 srand(（unsigned int）</span><br>        <br>    time（<span class="hljs-literal">NULL</span>））；<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><br>merge <span class="hljs-comment">//容器元素合并，并存储到另一容器中</span><br>merge（iterator beg1 ,iterator end1,iterator beg2 ,iterator end2，iterator dest)<br><span class="hljs-comment">//两个容器需要有序  ， dest 目标容器开始迭代器</span><br><br>reserve<span class="hljs-comment">//反转指定范围元素</span><br>reserve（iterator beg，erator end）<br></code></pre></td></tr></table></figure><h4 id="4-拷贝和替换"><a href="#4-拷贝和替换" class="headerlink" title="4.拷贝和替换"></a>4.拷贝和替换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">拷贝和替换：<br>copy <span class="hljs-comment">//</span><br>copy (itator beg ,iterator end，iterator dest）<br>replace  <span class="hljs-comment">//将旧元素替换为新元素</span><br>replace (itator beg ,iterator end，oldvalue,newvalue）<br><br>replace_if  <span class="hljs-comment">//</span><br>replace_if(itator beg ,iterator end，_pred ,newvalue）<br><span class="hljs-comment">//_pred谓词</span><br>swap<br>swap(container c1,container c2);<br></code></pre></td></tr></table></figure><h4 id="5-算数生成算法"><a href="#5-算数生成算法" class="headerlink" title="5.算数生成算法"></a>5.算数生成算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">算术生成算法：<br>注意：头文件  <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><br>accumulate   <span class="hljs-comment">//计算容器元素累计总和</span><br>accumulate（iterator beg ,iterator end，value）<br><br>fill         <span class="hljs-comment">//向容器中添加元素</span><br>fill（iterator beg ,iterator end，value）<br><br></code></pre></td></tr></table></figure><h4 id="6-常用算法集合"><a href="#6-常用算法集合" class="headerlink" title="6.常用算法集合"></a>6.常用算法集合</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">常用集合算法：<br>set_intersection      <span class="hljs-comment">//求两容器交集</span><br><br>set_intersection（iterator beg1 ,iterator end1,iterator beg2 ,iterator end2，iterator dest)<br><span class="hljs-comment">//注意：两容器必须是有序序列 ，dest目标容器开始迭代器</span><br><br>set_union            <span class="hljs-comment">//并集</span><br><br>set_union（iterator beg1 ,iterator end1,iterator beg2 ,iterator end2，iterator dest)<br><span class="hljs-comment">//注意：两容器必须是有序序列  ，dest目标容器开始迭代器</span><br><br>set_difference      <span class="hljs-comment">//差集</span><br>set_difference （iterator beg1 ,iterator end1,iterator beg2 ,iterator end2，iterator dest)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2020/04/03/00007-git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/04/03/00007-git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、git安装"><a href="#一、git安装" class="headerlink" title="一、git安装"></a>一、git安装</h1><p>[TOC]</p><h4 id="1-登录官网下载"><a href="#1-登录官网下载" class="headerlink" title="1.登录官网下载"></a>1.登录官网下载</h4><h4 id="2-双击安装"><a href="#2-双击安装" class="headerlink" title="2.双击安装"></a>2.双击安装</h4><p><img src="C:\Users\lenovo\Desktop\1.jpg" alt="1"></p><h4 id="3-选择安装目录"><a href="#3-选择安装目录" class="headerlink" title="3.选择安装目录"></a>3.选择安装目录</h4><h4 id="4-桌面创建图标，其余默认"><a href="#4-桌面创建图标，其余默认" class="headerlink" title="4.桌面创建图标，其余默认"></a>4.桌面创建图标，其余默认</h4><p><img src="C:\Users\lenovo\Desktop\2.jpg" alt="2"></p><h4 id="5-文本编辑器，默认"><a href="#5-文本编辑器，默认" class="headerlink" title="5.文本编辑器，默认"></a>5.文本编辑器，默认</h4><p><img src="C:\Users\lenovo\Desktop\3.jpg" alt="3"></p><h4 id="6-选择推荐设置"><a href="#6-选择推荐设置" class="headerlink" title="6.选择推荐设置"></a>6.选择推荐设置</h4><p><img src="C:\Users\lenovo\Desktop\4.jpg" alt="4"></p><h4 id="7-使用默认连接"><a href="#7-使用默认连接" class="headerlink" title="7.使用默认连接"></a>7.使用默认连接</h4><p><img src="C:\Users\lenovo\Desktop\5.jpg" alt="5"></p><h4 id="8-行末换行符转换方式，选择默认值"><a href="#8-行末换行符转换方式，选择默认值" class="headerlink" title="8.行末换行符转换方式，选择默认值"></a>8.行末换行符转换方式，选择默认值</h4><p><img src="C:\Users\lenovo\Desktop\6.jpg" alt="6"></p><h4 id="9-默认终端"><a href="#9-默认终端" class="headerlink" title="9.默认终端"></a>9.默认终端</h4><p><img src="C:\Users\lenovo\Desktop\7.jpg" alt="7"></p><h4 id="10-启用缓存、启用管理器"><a href="#10-启用缓存、启用管理器" class="headerlink" title="10.启用缓存、启用管理器"></a>10.启用缓存、启用管理器</h4><p><img src="C:\Users\lenovo\Desktop\8.jpg" alt="8"></p><h4 id="11-安装"><a href="#11-安装" class="headerlink" title="11.安装"></a>11.安装</h4><h4 id="12-右键验证是否完成"><a href="#12-右键验证是否完成" class="headerlink" title="12.右键验证是否完成"></a>12.右键验证是否完成</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585660142634.png" alt="1585660142634"></p><h1 id="二、注册GitHub"><a href="#二、注册GitHub" class="headerlink" title="二、注册GitHub"></a>二、注册GitHub</h1><h6 id="1-注册Github账户"><a href="#1-注册Github账户" class="headerlink" title="1.注册Github账户"></a>1.注册Github账户</h6><p><img src="C:\Users\lenovo\Desktop\任务\0.1.jpg" alt="0.1"></p><h6 id="2-选择账户类型"><a href="#2-选择账户类型" class="headerlink" title="2.选择账户类型"></a>2.选择账户类型</h6><p>​        选择免费用户</p><h6 id="3-问卷"><a href="#3-问卷" class="headerlink" title="3.问卷"></a>3.问卷</h6><h6 id="4-验证邮箱"><a href="#4-验证邮箱" class="headerlink" title="4.验证邮箱"></a>4.验证邮箱</h6><p>​        进入注册的邮箱，打开验证邮件，点击链接完成验证</p><h1 id="三、建立远程仓库"><a href="#三、建立远程仓库" class="headerlink" title="三、建立远程仓库"></a>三、建立远程仓库</h1><p>填写库名称，点击create respository创建项目</p><p>​    <img src="C:\Users\lenovo\Desktop\建库.jpg" alt="建库"></p><p><img src="C:\Users\lenovo\Desktop\建库2.jpg" alt="建库2"></p><h1 id="四、本地仓库上传到GitHub仓库"><a href="#四、本地仓库上传到GitHub仓库" class="headerlink" title="四、本地仓库上传到GitHub仓库"></a>四、本地仓库上传到GitHub仓库</h1><h4 id="1-文件保存到本地仓库"><a href="#1-文件保存到本地仓库" class="headerlink" title="1.文件保存到本地仓库"></a>1.文件保存到本地仓库</h4><pre><code>* 在D盘的GitHub文件加里有Address.txt，右键点击选择Git Bash Here</code></pre><p><img src="C:\Users\lenovo\Desktop\任务\01.jpg" alt="01"></p><p><img src="C:\Users\lenovo\Desktop\任务\02.jpg" alt="02"></p><h4 id="2-配置用户名和邮箱"><a href="#2-配置用户名和邮箱" class="headerlink" title="2.配置用户名和邮箱"></a>2.配置用户名和邮箱</h4><p><img src="C:\Users\lenovo\Desktop\任务\03.jpg" alt="03"></p><p>​        </p><pre><code>    * 输入 `git config --global user.name &quot;      &quot;`</code></pre><p>​                <code> git config --global user.email  &quot;      &quot;</code></p><p><img src="C:\Users\lenovo\Desktop\任务\04.jpg" alt="04"></p><p><img src="C:\Users\lenovo\Desktop\任务\05.jpg" alt="05"></p><h4 id="3-添加和提交"><a href="#3-添加和提交" class="headerlink" title="3.添加和提交"></a>3.添加和提交</h4><ul><li> 输入<code>git init  </code>初始化一个Git仓库 建立.git 文件夹</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\06.jpg" alt="06"></p><pre><code>    * 输入  `git add Address_test.txt`</code></pre><p>​            <code>    git commit -m &quot; (备注) &quot;</code></p><p><img src="C:\Users\lenovo\Desktop\任务\07.jpg" alt="07"></p><p><img src="C:\Users\lenovo\Desktop\任务\08.jpg" alt="08"></p><p>​        完成提交</p><h4 id="4-生产SSH密钥"><a href="#4-生产SSH密钥" class="headerlink" title="4.生产SSH密钥"></a>4.生产SSH密钥</h4><ul><li>输入<code>ssh-keygen -t rsa -C &quot;  (邮箱)  &quot;  </code>，再连续按3个回车</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\09-2.jpg" alt="09-2"></p><ul><li>根据界面提示找到 \.ssh目录下的<code> id_rsa.pub</code> 复制其中内容</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\10.jpg" alt="10"></p><ul><li>登录GitHub账号，点击Your profile</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\11-2.jpg" alt="11-2"></p><ul><li>点击<code>Edit profile</code></li></ul><p><img src="C:\Users\lenovo\Desktop\任务\13.jpg" alt="13"></p><ul><li>选择<code>SSH and GPG keys</code>，并新建SSH Key</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\15.jpg" alt="15"></p><ul><li><p>填写title ，将<code>id_rsa.pub</code>内容复制到 key 中，点击 <code>Add SSH Key</code>，密钥完成</p><p><img src="C:\Users\lenovo\Desktop\任务\16.jpg" alt="16"></p></li></ul><p><img src="C:\Users\lenovo\Desktop\任务\17.jpg" alt="17"></p><h4 id="5-远程提交"><a href="#5-远程提交" class="headerlink" title="5.远程提交"></a>5.远程提交</h4><ul><li>添加新的远程仓库</li></ul><p><img src="C:\Users\lenovo\Desktop\任务\18.jpg" alt="18"></p><p><img src="C:\Users\lenovo\Desktop\任务\19.jpg" alt="19"></p><ul><li><p>再输入 <code>git push -u origin master</code></p></li><li><p>之后，可以在GitHub的mytest仓库中看到，多出一个Address.txt文件</p></li></ul><p><img src="C:\Users\lenovo\Desktop\任务\21.jpg" alt="21"></p><h1 id="五、git学习"><a href="#五、git学习" class="headerlink" title="五、git学习"></a>五、git学习</h1><h4 id="1-将文件加入仓库"><a href="#1-将文件加入仓库" class="headerlink" title="1.将文件加入仓库"></a>1.将文件加入仓库</h4><ul><li>第一步： 输入 <code>git add </code>       //将需要进行版本控制的文件加入仓库，这样git才可以管理加入文件的版本，使这些文件被 git 跟踪，以便之后的记录修改等 ，可以发福使用多次，添加多个文件</li><li>或者  输入<code>git add .    </code> //最后还有个 点 ，一个点表示当前路径，表示把当前路径下的文件全部加入本地仓库 </li><li>第二步：使用 <code>git commit -m &lt;message&gt;</code></li></ul><h4 id="2-查看修改"><a href="#2-查看修改" class="headerlink" title="2.查看修改"></a>2.查看修改</h4><ul><li><p><code>git status</code> //查看仓库当前状态</p><p>如下图，表示已被修改，但尚未提交</p></li></ul><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585682314848.png" alt="1585682314848"></p><ul><li><p><code>git diff</code> //查看修改</p><p>如下图</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585682472368.png" alt="1585682472368"></p></li><li><p><code>git log</code> //显示从最近到最远的提交日志，查看版本历史</p></li></ul><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585682992243.png" alt="1585682992243"></p><ul><li><p><code>git log --pretty=oneline</code>  //每个版本放在一行</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585683088254.png" alt="1585683088254"></p></li></ul><h4 id="3-回到以前版本"><a href="#3-回到以前版本" class="headerlink" title="3.回到以前版本"></a>3.回到以前版本</h4><ul><li><code>HEAD</code>表示当前版本，上一版本<code>HEAD^</code> ,上上一个版本<code>HEAD^^</code> ,往上100个<code>HEAD~100</code></li><li><code>git reset --hard HEAD^</code>  //回到上一个版本</li></ul><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585683390713.png" alt="1585683390713"></p><p>​        回到上一版本</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585683541785.png" alt="1585683541785"></p><ul><li><p>也可用<code>git reset --hard 9714f</code>   回到add版本</p></li><li><p><code>git reflog</code>   //记录每一次命令，查看命令历史</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585683819356.png" alt="1585683819356"></p></li></ul><h4 id="4-撤销修改"><a href="#4-撤销修改" class="headerlink" title="4.撤销修改"></a>4.撤销修改</h4><ul><li><p><code>git checkout -- readme.txt</code>  //把<code>readme.txt</code>文件在工作区的修改全部撤销</p><p>两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，让文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态</p></li><li><p><code>git reset HEAD </code>//已经修改，并放入暂存区，就此命令回到了上一场景，再按上一场景操作</p></li><li><p>已经提交了不合适的修改到版本库时，想要撤销本次提交，需要通过版本回退，不过前提是没有推送到远程库 </p></li></ul><h4 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5.删除文件"></a>5.删除文件</h4><ul><li><p><code>rm test0.txt</code>  //用rm命令删除</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585684826117.png" alt="1585684826117"></p></li><li><p><code>git rm</code> </p><p><code>git commit -m &quot;remove test0.txt&quot;</code>    //从版本库删除文件</p></li></ul><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585685060811.png" alt="1585685060811"></p><ul><li><code>git checkout -- test0.txt&quot;</code> //一键恢复，不过前提是文件之前已经被添加到版本库</li><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong> </li></ul><h4 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h4><h5 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h5><ul><li><p><code>git branch</code>  //查看分支</p></li><li><p><code>git checkout master</code> //切换到需要打标签的分支上 </p></li></ul><p>  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585685649203.png" alt="1585685649203"></p><ul><li><p><code>git tag v1.0</code> //加标签</p></li><li><p><code>git tag  </code>  //查看所有标签 </p></li></ul><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585685778961.png" alt="1585685778961"></p><ul><li><p><code>git tag v0.9 f52c633</code>  //对f52c633  打标签v0.9</p></li><li><p>标签不是按时间顺序列出，而是按字母排序的 </p></li><li><p><code>git show  v1.0</code>     //查看标签信息</p></li></ul><p>  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585685991724.png" alt="1585685991724"></p><ul><li><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code> // 创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字 </li></ul><h5 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h5><ul><li><p><code>git push origin </code>可以推送一个本地标签 到远程</p><ul><li><code>git push origin v1.0</code></li></ul></li><li><p> <code>git push origin --tags</code>可以推送全部未推送过的本地标 签</p></li><li><p> <code>git tag -d </code>可以删除一个本地标签 </p></li></ul><p>  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1585686285895.png" alt="1585686285895"></p><ul><li> <code>git push origin :refs/tags/</code>可以删除一个远程标签 </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/2020/03/28/00005-vim%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/03/28/00005-vim%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="学习vim的基本操作"><a href="#学习vim的基本操作" class="headerlink" title="学习vim的基本操作"></a>学习vim的基本操作</h1><p>[TOC]</p><h4 id="1、vim的三种模式"><a href="#1、vim的三种模式" class="headerlink" title="1、vim的三种模式"></a>1、vim的三种模式</h4><p>​    命令模式 </p><p>​    输入模式  </p><p>​    末行模式</p><h4 id="2、模式转化"><a href="#2、模式转化" class="headerlink" title="2、模式转化"></a>2、模式转化</h4><p>​    </p><pre><code>* 编辑到输入</code></pre><p>​        i: 在当前光标所在字符的前面，转为输入模式；    </p><p>​        a: 在当前光标所在字符的后面，转为输入模式；    </p><p>​        o: 在当前光标所在行的下方，新建一行，并转为输入模式；    </p><p>​         I：在当前光标所在行的行首，转换为输入模式   </p><p>​         A：在当前光标所在行的行尾，转换为输入模式    </p><p>​         O：在当前光标所在行的上方，新建一行，并转为输入模式；</p><ul><li>输入到编辑  ：           ESC</li><li>编辑 到末行  ：             ：</li><li>末行到编辑：        ESC,ESC</li></ul><h4 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h4><p>​      /text　查找text，按n健查找下一个，按N健查找前一个。</p><p>​      ?text　查找text，反向查找，按n健查找下一个，按N健查找前一个。</p><p>​       vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</p><p>​       :set ignorecase　忽略大小写的查找</p><p>​       :set noignorecase　不忽略大小写的查找 ，查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</p><p>​       :set hlsearch　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</p><p>​       :set nohlsearch　关闭高亮搜索显示</p><p>​       :nohlsearch　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</p><p>​        :set incsearch　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</p><p>​        :set wrapscan　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p><h4 id="4、插入"><a href="#4、插入" class="headerlink" title="4、插入"></a>4、插入</h4><p>i 在当前位置前插入</p><p>I 在当前行首插入</p><p>a 在当前位置后插入</p><p>A 在当前行尾插入</p><p>o 在当前行之后插入一行</p><p>O 在当前行之前插入一行</p><h4 id="5、替换"><a href="#5、替换" class="headerlink" title="5、替换"></a>5、替换</h4><p>ra 将当前字符替换为a，当期字符即光标所在字符。</p><p>s/old/new/ 用old替换new，替换当前行的第一个匹配</p><p>s/old/new/g 用old替换new，替换当前行的所有匹配</p><p>%s/old/new/ 用old替换new，替换所有行的第一个匹配</p><p>%s/old/new/g 用old替换new，替换整个文件的所有匹配</p><p>:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。</p><p>ddp 交换光标所在行和其下紧邻的一行。</p><h4 id="6、删除"><a href="#6、删除" class="headerlink" title="6、删除"></a>6、删除</h4><p>x 删除当前字符</p><p>3x 删除当前光标开始向后三个字符</p><p>X 删除当前字符的前一个字符。X=dh</p><p>dl 删除当前字符， dl=x</p><p>dh 删除前一个字符</p><p>dd 删除当前行</p><p>dj 删除上一行</p><p>dk 删除下一行</p><p>10d 删除当前行开始的10行。</p><p>D 删除当前字符至行尾。D=d$</p><p>d$ 删除当前字符之后的所有字符（本行）</p><p>kdgg 删除当前行之前所有行（不包括当前行）</p><p>jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）</p><p>:1,10d 删除1-10行</p><p>:11,$d 删除11行及以后所有的行</p><p>:1,$d 删除所有行</p><p>J(shift + j)　　删除两行之间的空行，实际上是合并两行</p><h4 id="7、快速跳转"><a href="#7、快速跳转" class="headerlink" title="7、快速跳转"></a>7、快速跳转</h4><ul><li>跳到指定行<br>ngg 或者 nG                    n为指定的行数，如12gg或者12G 跳转到第12行.</li></ul><p>​       gg                                      跳转到当前文件的第一行</p><p>​       G                                       跳转光标到当前文件的最后一行</p><p>​         :n                                    在命令模式下输入行号n</p><p>​     vim +n FileName             打开文件即跳转到指定行，行号n</p><ul><li>跳转到当前行的指定列<br>0 或 |            :  跳转光标到当前行的行首。<br>$                     :  跳转光标到当前行的行尾<br> 0nl 或 n|       : 跳转到当前行的第 n 列</li></ul><h4 id="8、保存文档"><a href="#8、保存文档" class="headerlink" title="8、保存文档"></a>8、保存文档</h4><p> 从普通模式输入:进入命令行模式，输入w回车，保存文档。输入:w 文件名可以将文档另存为其他文件名或存到其它路径下 </p><h4 id="9、退出vim"><a href="#9、退出vim" class="headerlink" title="9、退出vim"></a>9、退出vim</h4><p> 从普通模式输入<code>:</code>进入命令行模式，输入<code>wq</code>回车，保存并退出编辑 </p><p>：q！                                     ：强制退出，不保存</p><p>：q                                         ：退出</p><p>：wq！                                   ：强制退出，不保存</p><p>：w&lt;文件路径&gt;                      ：另存为</p><p>：saveas 文件路径                 ：另存为</p><p>：x                                            ：保存并退出</p><p>：wq                                         ：保存并退出</p>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2020/03/27/00004-Linux/"/>
    <url>/2020/03/27/00004-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux系统的常见命令"><a href="#Linux系统的常见命令" class="headerlink" title="Linux系统的常见命令"></a>Linux系统的常见命令</h1><p>[TOC]</p><h3 id="1-常用指令"><a href="#1-常用指令" class="headerlink" title="1.常用指令"></a>1.常用指令</h3><h6 id="ls：-显示文件或目录"><a href="#ls：-显示文件或目录" class="headerlink" title="ls： 显示文件或目录"></a>ls： 显示文件或目录</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ls</span> <span class="hljs-selector-attr">[-alrtAFR]</span><span class="hljs-selector-attr">[name...]</span><br></code></pre></td></tr></table></figure><p>   -l      列出文件详细信息l(list)</p><p>   -a      列出当前目录下所有文件及目录，包括隐藏的a(all)</p><p>   -R      若目录下有文件，则以下之文件亦皆依序列出</p><p>   -r       将文件以相反次序显示(原定依英文字母次序)</p><p>   -t        将文件依建立时间之先后次序列出</p><p>例如 :    ls /     (列出根目录下的所有目录)</p><h6 id="cp-拷贝"><a href="#cp-拷贝" class="headerlink" title="cp:         拷贝"></a>cp:         拷贝</h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [-adfiprl] <span class="hljs-keyword">source</span> dest<br>或  <span class="hljs-keyword">cp</span> [-adfiprl] <span class="hljs-keyword">source</span>... directory<br></code></pre></td></tr></table></figure><p>  -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容 </p><p>   -d：复制时保留链接 </p><p>   -f：覆盖已经存在的目标文件而不给出提示 </p><p>​     -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件 </p><p>​     -l：不复制文件，只是生成链接文件 </p><p>例如：  cp –r test/ newtest      （将目录“test/”下的所有文件复制到新目录“newtest”下）</p><h6 id="mv：-移动或重命名"><a href="#mv：-移动或重命名" class="headerlink" title="mv：     移动或重命名"></a>mv：     移动或重命名</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv [-<span class="hljs-keyword">if</span>] <span class="hljs-built_in">source</span> dest<br>或  mv [-<span class="hljs-keyword">if</span>] <span class="hljs-built_in">source</span>... directory<br></code></pre></td></tr></table></figure><p>​    -i： 若指定目录已有同名文件，则先询问是否覆盖旧文件 </p><p>​    -f： 在 mv 操作要覆盖某已有的目标文件时不给任何指示</p><table><thead><tr><th>命令格式</th><th>运行后</th></tr></thead><tbody><tr><td>mv 文件名 文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv 文件名 目录名</td><td>将文件移动到目标目录</td></tr><tr><td>mv 目录名 目录名</td><td>目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td>mv 目录名 文件名</td><td>出错</td></tr></tbody></table><h6 id="rm-：-删除文件"><a href="#rm-：-删除文件" class="headerlink" title="rm ：       删除文件"></a>rm ：       删除文件</h6><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">rm [-ifr] name...<br></code></pre></td></tr></table></figure><p>   -r       递归删除,可删除子目录及文件(删除目录时，需要使用)</p><p>   -i        删除前逐一询问确认</p><p>   -f       强制删除</p><p>特：rm -r *    ( 删除当前目录下的所有文件及目录 )</p><p>文件一旦删除，无法恢复！</p><h6 id="touch-创建空文件"><a href="#touch-创建空文件" class="headerlink" title="touch  :    创建空文件"></a>touch  :    创建空文件</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">touch</span> <span class="hljs-selector-attr">[-acfm]</span><span class="hljs-selector-attr">[-d&lt;日期时间&gt;]</span><span class="hljs-selector-attr">[-r&lt;参考文件或目录&gt;]</span> <span class="hljs-selector-attr">[-t&lt;日期时间&gt;]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[文件或目录…]</span><br></code></pre></td></tr></table></figure><p>例如：touch file            （创建一个名为“file”的新的空白文件）</p><h6 id="echo-创建带有内容的文件。"><a href="#echo-创建带有内容的文件。" class="headerlink" title="echo       创建带有内容的文件。"></a>echo       创建带有内容的文件。</h6><h6 id="cat-查看文件内容"><a href="#cat-查看文件内容" class="headerlink" title="cat  :       查看文件内容"></a>cat  :       查看文件内容</h6><h6 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir  :   创建目录"></a>mkdir  :   创建目录</h6><p>​        -p      创建目录，若无父目录，则创建p(parent)</p><h6 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd  :      切换目录"></a>cd  :      切换目录</h6><h6 id="wc-统计文本中行数、字数、字符数"><a href="#wc-统计文本中行数、字数、字符数" class="headerlink" title="wc :        统计文本中行数、字数、字符数"></a>wc :        统计文本中行数、字数、字符数</h6><h6 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir   :   删除空目录"></a>rmdir   :   删除空目录</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">rmdir</span> [-p] dirName<br></code></pre></td></tr></table></figure><p>​        -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。</p><p>例如：rmdir AAA  （ 将工作目录下，名为 AAA 的子目录删除 ）</p><p>​            rmdir -p BBB/Test  （ 在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除  ）</p><h3 id="2-文件查找方式及区别"><a href="#2-文件查找方式及区别" class="headerlink" title="2.文件查找方式及区别"></a>2.文件查找方式及区别</h3><h6 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h6><p>该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。</p><p>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">whereis</span> <span class="hljs-selector-attr">[-bfmsu]</span><span class="hljs-selector-attr">[-B &lt;目录&gt;...]</span><span class="hljs-selector-attr">[-M &lt;目录&gt;...]</span><span class="hljs-selector-attr">[-S &lt;目录&gt;...]</span><span class="hljs-selector-attr">[文件...]</span><br></code></pre></td></tr></table></figure><p>​    -b 　只查找二进制文件。</p><p>​    -B&lt;目录&gt; 　只在设置的目录下查找二进制文件。</p><p>​    -f 　不显示文件名前的路径名称。</p><p>​    -m 　只查找说明文件。</p><p>​    -M&lt;目录&gt; 　只在设置的目录下查找说明文件。</p><p>​    -s 　只查找原始代码文件。</p><p>​     -S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。</p><p>​      -u 　查找不包含指定类型的文件</p><h6 id="find"><a href="#find" class="headerlink" title="find"></a>find</h6><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span>   path   -option   [   -<span class="hljs-builtin-name">print</span> ]   [ -exec   -ok   command ]   &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>   path 和 expression： 在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 </p><h3 id="3-软链接、硬链接以及区别"><a href="#3-软链接、硬链接以及区别" class="headerlink" title="3.软链接、硬链接以及区别"></a>3.软链接、硬链接以及区别</h3><h6 id="ln：-为某一个文件在另外一个位置建立一个同步的链接"><a href="#ln：-为某一个文件在另外一个位置建立一个同步的链接" class="headerlink" title="ln：  为某一个文件在另外一个位置建立一个同步的链接"></a>ln：  为某一个文件在另外一个位置建立一个同步的链接</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ln</span> <span class="hljs-selector-attr">[参数]</span><span class="hljs-selector-attr">[源文件或目录]</span><span class="hljs-selector-attr">[目标文件或目录]</span><br></code></pre></td></tr></table></figure><p>参数格式： [-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p><p>[–help] [–version] [–]</p><p>必要参数：</p><ul><li>-b 删除，覆盖以前建立的链接</li><li>-d 允许超级用户制作目录的硬链接</li><li>-f 强制执行</li><li>-i 交互模式，文件存在则提示用户是否覆盖</li><li>-n 把符号链接视为一般目录</li><li>-s 软链接(符号链接)</li><li>-v 显示详细的处理过程</li></ul><p>选择参数：</p><ul><li>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”</li><li>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”</li><li>–help 显示帮助信息</li><li>–version 显示版本信息</li></ul><h6 id="两种链接："><a href="#两种链接：" class="headerlink" title="两种链接："></a>两种链接：</h6><p>为解决文件的共享使用，Linux 系统引入了两种链接：</p><p>硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）</p><h6 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h6><p>是有着相同 inode 号仅文件名不同的文件，特性：</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><h6 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h6><p>就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块， 产生一个特殊的档案，该档案的内容是指向另一个档案的位置 ，特性：</p><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ul><h3 id="4-在ubuntu下新建用户，设置权限，删除用户"><a href="#4-在ubuntu下新建用户，设置权限，删除用户" class="headerlink" title="4.在ubuntu下新建用户，设置权限，删除用户"></a>4.在ubuntu下新建用户，设置权限，删除用户</h3><h5 id="创建用户目录"><a href="#创建用户目录" class="headerlink" title="创建用户目录"></a>创建用户目录</h5><p>​    打开terminal</p><ul><li><p>sudo useradd -r -m -s /bin/bash  newyetan</p></li><li><p>ll /home/</p></li><li><p>ls /home/</p></li></ul><h5 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h5><p>因为此文件只有r权限，在改动前需要增加w权限，改动后，再去掉w权限。 </p><ul><li><p>sudo chmod +w /etc/sudoers</p></li><li><p>sudo vim /etc/sudoers</p><p>![IMG_20200327_184707](C:\Users\lenovo\Documents\Tencent Files\2449579323\FileRecv\MobileFile\IMG_20200327_184707.jpg)</p></li></ul><p>  在 #User privilege specification</p><p>  ​        root　ALL=(ALL:ALL) ALL处,下行写入：</p><p>  ​       newyetan ALL=(ALL:ALL) ALL</p><p>  ​        之后，按Esc推出insert模式，再点：w保存</p><p>  创建完成，权限设置完成</p><h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><ul><li><p>执行userdel命令：sudo userdel newyetan</p><pre><code>*  删除用户目录命令：sudo rm -rf /home/newyetan</code></pre></li></ul><h3 id="5-通过命令行，连接有线网、无线网"><a href="#5-通过命令行，连接有线网、无线网" class="headerlink" title="5.通过命令行，连接有线网、无线网"></a>5.通过命令行，连接有线网、无线网</h3><h6 id="查看是否已经正确安装无线网卡"><a href="#查看是否已经正确安装无线网卡" class="headerlink" title="查看是否已经正确安装无线网卡"></a>查看是否已经正确安装无线网卡</h6><p>iwconfig</p><h6 id="启动无线网卡-如果网卡是wlan0"><a href="#启动无线网卡-如果网卡是wlan0" class="headerlink" title="启动无线网卡(如果网卡是wlan0 )"></a>启动无线网卡(如果网卡是wlan0 )</h6><p>ifconfig wlan0 up</p><h6 id="扫描可用的WiFi"><a href="#扫描可用的WiFi" class="headerlink" title="扫描可用的WiFi"></a>扫描可用的WiFi</h6><p>iwlist wlan0 scanning </p><h6 id="创建口令文件-并连接"><a href="#创建口令文件-并连接" class="headerlink" title="创建口令文件, 并连接"></a>创建口令文件, 并连接</h6><p>wpa_passphrase ESSID PWD &gt; xxx.conf </p><p>wpa_supplicant -B -i wlan0 -Dwext -c ./xxx.conf</p><p>iwconfig wlan0 </p><p>dhclient wlan0 </p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>考核初战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown</title>
    <link href="/2020/03/26/00003-Markdown/"/>
    <url>/2020/03/26/00003-Markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><p>[TOC]</p><h2 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h2><p>​    n个#+空格+标题，enter，转化为相应n级标题</p><p>#–&gt;</p><h1 id="Header-1"><a href="#Header-1" class="headerlink" title="Header 1"></a>Header 1</h1><h2 id="Header-2"><a href="#Header-2" class="headerlink" title="Header 2"></a>Header 2</h2><h3 id="Header3"><a href="#Header3" class="headerlink" title="Header3"></a>Header3</h3><h4 id="Header4"><a href="#Header4" class="headerlink" title="Header4"></a>Header4</h4><h5 id="Header-5"><a href="#Header-5" class="headerlink" title="Header 5"></a>Header 5</h5><h2 id="2、斜体、粗体、加粗斜体、删除线"><a href="#2、斜体、粗体、加粗斜体、删除线" class="headerlink" title="2、斜体、粗体、加粗斜体、删除线"></a>2、斜体、粗体、加粗斜体、删除线</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体*</span><br><span class="hljs-emphasis">_斜体_</span><br><span class="hljs-strong">**粗体**</span><br><span class="hljs-emphasis">__粗体__</span><br><span class="hljs-strong">***加粗斜体**</span>*<br>~~删除线~~<br></code></pre></td></tr></table></figure><p><em>斜体</em></p><p><em>斜体</em></p><p><strong>粗体</strong></p><p><strong>粗体</strong></p><p><strong><em>加粗斜体</em></strong></p><p><del>删除线</del></p><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h2><ul><li>多级引用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">可多层嵌套<br><span class="hljs-meta">&gt;</span><span class="bash">引用某人的一句话</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;两层嵌套</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>多层嵌套</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><p>引用某人的一句话</p></blockquote></blockquote><blockquote><blockquote><p>两层嵌套</p><blockquote><blockquote><p>多层嵌套</p></blockquote></blockquote></blockquote></blockquote></blockquote><ul><li><p>引用代码块</p><blockquote><p>​    这是引用的代码块形式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br> setContentView(R.layout.activity_main);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、列表"><a href="#4、列表" class="headerlink" title="4、列表"></a>4、列表</h2></li></ul><p>无序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> one<br><span class="hljs-bullet">*</span> two<br><span class="hljs-bullet">+</span> three<br></code></pre></td></tr></table></figure><pre><code>    * one    * two</code></pre><ul><li>three</li></ul><p>有序列表</p><p>​    数字+ .</p><ol><li>one</li><li>two</li></ol><h2 id="5、表格"><a href="#5、表格" class="headerlink" title="5、表格"></a>5、表格</h2><ul><li><h4 id="居左："><a href="#居左：" class="headerlink" title="居左："></a>居左：</h4></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">：<span class="hljs-comment">----</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="居中"><a href="#居中" class="headerlink" title="居中:"></a>居中:</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:----</span><span class="hljs-symbol">:</span>或者-----<br></code></pre></td></tr></table></figure></li><li><h4 id="居右"><a href="#居右" class="headerlink" title="居右:"></a>居右:</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">----:</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>标题</th><th align="center">标题</th><th align="right">标题</th></tr></thead><tbody><tr><td></td><td align="center"></td><td align="right"></td></tr><tr><td></td><td align="center"></td><td align="right"></td></tr><tr><td></td><td align="center"></td><td align="right"></td></tr></tbody></table></li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">姓名|<span class="hljs-string">技能</span>|<span class="hljs-string">排行</span><br><span class="hljs-string">--</span>|<span class="hljs-string">:--:</span>|<span class="hljs-string">--:</span><br><span class="hljs-string">刘备</span>|<span class="hljs-string">哭</span>|<span class="hljs-string">大哥</span><br><span class="hljs-string">关羽</span>|<span class="hljs-string">打</span>|<span class="hljs-string">二哥</span><br><span class="hljs-string">张飞</span>|<span class="hljs-string">骂</span>|<span class="hljs-string">三弟</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="6、链接"><a href="#6、链接" class="headerlink" title="6、链接"></a>6、链接</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[描述]</span>（链接地址）<br></code></pre></td></tr></table></figure><p><a href="http://learn.nwpu.edu.cn/">西工大课程平台</a></p><h2 id="7、图片"><a href="#7、图片" class="headerlink" title="7、图片"></a>7、图片</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">！<span class="hljs-selector-attr">[图片文本(可忽略)]</span>(图片地址“图片title”)<br>!<span class="hljs-selector-attr">[]</span>(img src=<span class="hljs-string">&quot;C:\Users\lenovo\Pictures\励志壁纸\fec091886201672ddba90ff2915b8baf.jpg&quot;</span> style=<span class="hljs-string">&quot;zoom:80%;&quot;</span> /)<br></code></pre></td></tr></table></figure><h2 id="8、分割线"><a href="#8、分割线" class="headerlink" title="8、分割线"></a>8、分割线</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">***</span><br>---<br></code></pre></td></tr></table></figure><hr><hr><h2 id="9、代码框"><a href="#9、代码框" class="headerlink" title="9、代码框"></a>9、代码框</h2><p>注意反引号位置：1的左边</p><p>分为行内代码和代码块</p><ul><li><p>行内代码使用 <code>代码</code> 标识,可嵌入文字中</p><p><code>create database hero;</code></p></li><li><p>代码块使用4个空格或```标识</p><p>```<br>代码<br>```</p></li></ul><p>  代码语法高亮在``` 后面加上 <code>空格</code>和语言名称</p><p>  ``` 语言<br>  //注意语言前面有空格<br>  代码<br>  ```</p><p>`</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>``` java<br><span class="hljs-comment">// java前面有空格</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_main);<br>&#125;<br>```<br></code></pre></td></tr></table></figure><h2 id="10、注解"><a href="#10、注解" class="headerlink" title="10、注解"></a>10、注解</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">这是一个脚注的例子<span class="hljs-selector-attr"><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里是脚注">[1]</span></a></sup></span><br><br><span class="hljs-selector-attr"><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里是脚注">[1]</span></a></sup></span>: 这里是脚注<br></code></pre></td></tr></table></figure><p>这是一个脚注的例子<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里是脚注">[1]</span></a></sup></p><h2 id="11、插入目录"><a href="#11、插入目录" class="headerlink" title="11、插入目录"></a>11、插入目录</h2><h3 id="1）-自动生成"><a href="#1）-自动生成" class="headerlink" title="1） 自动生成"></a>1） 自动生成</h3><p>直接输入<code>[toc]</code>，1-6个#均会被捕获</p><h3 id="2）npm语法"><a href="#2）npm语法" class="headerlink" title="2）npm语法"></a>2）npm语法</h3><ul><li><p>全局安装doctoc插件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm i doctoc -g <span class="hljs-regexp">//</span> install 简写 i<br></code></pre></td></tr></table></figure></li><li><p>在md文件目录下  ，右键，git bash here，执行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">doctoc</span> <span class="hljs-selector-tag">demo</span><span class="hljs-selector-class">.md</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1597317993640.png" alt="1597317993640"></p></li></ul><h2 id="12、绘图"><a href="#12、绘图" class="headerlink" title="12、绘图"></a>12、绘图</h2><p><a href="https://blog.csdn.net/kl28978113/article/details/93617103">markdown 绘制流程图、时序图、甘特图</a></p><ul><li>流程图——指定 <code>mermaid</code>（样式流程图） 或 <code>flow</code> （标准流程图）解析语言</li><li>时序图——指定 <code>sequence</code>（标准时序图） 或 <code>mermaid</code>（样式时序图） 解析语言</li><li>甘特图——指定 <code>mermaid</code> 解析语言</li></ul><h3 id="1）流程图"><a href="#1）流程图" class="headerlink" title="1）流程图"></a>1）流程图</h3><h4 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h4><p><strong>说明：</strong></p><p> 流程图大致分为两部分：</p><p>​        第一段：定义元素</p><p>​        第二段：定义元素之间的走向 </p><p><strong>定义元素：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">tag</span>=&gt;<span class="hljs-built_in">type</span>: conten<span class="hljs-variable">t:</span>&gt;url<br></code></pre></td></tr></table></figure><ul><li><p>tag就是元素名字，</p></li><li><p>type是这个元素的类型，有6中类型：</p><ul><li><p>start         # 开始</p></li><li><p>end           # 结束</p></li><li><p>operation     # 操作</p></li><li><p>subroutine    # 子程序</p></li><li><p>condition     # 条件</p></li><li><p>inputoutput   # 输入或产出</p></li><li><p>content就是在框框中要写的内容，注意type后的冒号与文本之间一定要有个空格。</p></li><li><p>url是一个连接，与框框中的文本相绑定</p></li></ul></li></ul><p><strong>连接元素：</strong></p><p> 用**-&gt;**来连接两个元素，需要注意的是condition类型，因为他有yes和no两个分支 </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">c2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>io-&gt;e <br>c2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>op2-&gt;e<br></code></pre></td></tr></table></figure><p><strong>应用：</strong></p><p>​    在代码块中，键入语法，选择语言<code>flow</code></p><p>eg :one:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">flow<br>st=&gt;start: Start<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes <span class="hljs-keyword">or</span> No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>e<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>op<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs flow">flow<br>st&#x3D;&gt;start: Start<br>op&#x3D;&gt;operation: Your Operation<br>cond&#x3D;&gt;condition: Yes or No?<br>e&#x3D;&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br></code></pre></td></tr></table></figure><p>eg :two:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livescript">flow<br>st=&gt;start: Start|past:&gt;http:<span class="hljs-regexp">//www.google.com[blank]</span><br><span class="hljs-regexp">e=&gt;end: End:&gt;http://</span>www.google.com<br>op1=&gt;operation: get_hotel_ids|past<br>op2=&gt;operation: get_proxy|current<br>sub1=&gt;subroutine: get_proxy|current<br>op3=&gt;operation: save_comment|current<br>op4=&gt;operation: set_sentiment|current<br>op5=&gt;operation: set_record|current<br><br>cond1=&gt;condition: ids_remain空?<br>cond2=&gt;condition: proxy_list空?<br>cond3=&gt;condition: ids_got空?<br>cond4=&gt;condition: 爬取成功??<br>cond5=&gt;condition: ids_remain空?<br><br>io1=&gt;inputoutput: ids-remain<br>io2=&gt;inputoutput: proxy_list<br>io3=&gt;inputoutput: ids-got<br><br>st-&gt;op1<span class="hljs-function"><span class="hljs-params">(right)</span>-&gt;</span>io1-&gt;cond1<br>cond1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>sub1-&gt;io2-&gt;cond2<br>cond2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>op3<br>cond2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>sub1<br>cond1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>op3-&gt;cond4<br>cond4<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>io3-&gt;cond3<br>cond4<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>io1<br>cond3<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>op4<br>cond3<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>, right)</span>-&gt;</span>cond5<br>cond5<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>op5<br>cond5<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>cond3<br>op5-&gt;e<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs flow">flow<br>st&#x3D;&gt;start: Start|past:&gt;http:&#x2F;&#x2F;www.google.com[blank]<br>e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.google.com<br>op1&#x3D;&gt;operation: get_hotel_ids|past<br>op2&#x3D;&gt;operation: get_proxy|current<br>sub1&#x3D;&gt;subroutine: get_proxy|current<br>op3&#x3D;&gt;operation: save_comment|current<br>op4&#x3D;&gt;operation: set_sentiment|current<br>op5&#x3D;&gt;operation: set_record|current<br><br>cond1&#x3D;&gt;condition: ids_remain空?<br>cond2&#x3D;&gt;condition: proxy_list空?<br>cond3&#x3D;&gt;condition: ids_got空?<br>cond4&#x3D;&gt;condition: 爬取成功??<br>cond5&#x3D;&gt;condition: ids_remain空?<br><br>io1&#x3D;&gt;inputoutput: ids-remain<br>io2&#x3D;&gt;inputoutput: proxy_list<br>io3&#x3D;&gt;inputoutput: ids-got<br><br>st-&gt;op1(right)-&gt;io1-&gt;cond1<br>cond1(yes)-&gt;sub1-&gt;io2-&gt;cond2<br>cond2(no)-&gt;op3<br>cond2(yes)-&gt;sub1<br>cond1(no)-&gt;op3-&gt;cond4<br>cond4(yes)-&gt;io3-&gt;cond3<br>cond4(no)-&gt;io1<br>cond3(no)-&gt;op4<br>cond3(yes, right)-&gt;cond5<br>cond5(yes)-&gt;op5<br>cond5(no)-&gt;cond3<br>op5-&gt;e<br></code></pre></td></tr></table></figure><h4 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h4><p>参考：</p><ul><li><p><a href="https://blog.csdn.net/wangyaninglm/article/details/52887045">markdown绘图插件—-mermaid简介</a></p></li><li><p><a href="http://note.youdao.com/iyoudao/?p=2411">【简明版】有道云笔记Markdown指南</a></p></li></ul><h2 id="13、图标"><a href="#13、图标" class="headerlink" title="13、图标"></a>13、图标</h2><p>英文模式下，输入冒号<code>:</code> ,再输入其它一个或多个数字或字母</p><p>:100:</p><p>:1st_place_medal:</p><p>:2nd_place_medal:</p><p>:point_up_2:</p><p>:3rd_place_medal:</p><p>:zero::one::two::three::four::five::six::seven::eight::nine::keycap_ten:</p><p>:accept::baby::baby_bottle::baby_chick::arrow_down_small::e-mail::camera_flash::dog::sparkling_heart:</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里是脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>考核初战</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/2020/03/15/00002-hexo-blog/"/>
    <url>/2020/03/15/00002-hexo-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="BLOG"><a href="#BLOG" class="headerlink" title="BLOG"></a>BLOG</h1><p>这里是一些参考链接，希望能提供一些帮助~</p><ol><li><a href="https://blog.csdn.net/weixin_42429718/article/details/105723193?utm_source=app">Hexo+Github+Coding 博客butterfly 和 matery 主题 搭建完全教程</a></li><li><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-44">洪卫的博客</a></li><li><a href="https://hexo.io/zh-cn/docs/configuration">配置</a></li><li><a href="https://sitoi.cn/posts/63466.html"> 基于 Hexo GitHub 从零开始搭建个人博客 </a></li><li><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/">hexo-script使用文档</a></li><li><a href="https://hexo.fluid-dev.com/docs">fluid 官方文档 </a></li><li><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/yi-jian-bu-shu-hexo-bo-ke">简洁配置</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid github</a></li><li><a href="https://www.jianshu.com/p/785d727810b3">添加评论 </a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">title: 404<br>date: 2020-12-12 23:59:59<br>type: &quot;404&quot;<br>layout: &quot;404&quot;<br>description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>diary</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><p><img src="F:\BLOG\bolg\hexoblog\themes\fluid\source\img\15.png" alt="15"></p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>contact</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
